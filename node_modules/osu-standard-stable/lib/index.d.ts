import * as osu_classes from 'osu-classes';
import { ModCombination, IMod, HitObject, IHasPosition, IHasComboInformation, HitWindows, Vector2, ControlPointInfo, BeatmapDifficultySection, ISlidableObject, SliderPath, HitSample, ISpinnableObject, EventGenerator, RulesetBeatmap, BeatmapConverter, IBeatmap, BeatmapProcessor, DifficultyAttributes, ModBitwise, ModType, Autoplay, Cinema, DoubleTime, Easy, Flashlight as Flashlight$1, HalfTime, HardRock, IApplicableToHitObjects, Hidden, IApplicableToBeatmap, Nightcore, NoFail, NoMod, Perfect, Relax, SuddenDeath, PerformanceAttributes, DifficultyHitObject, IHitObject, StrainSkill, DifficultyCalculator, Skill, PerformanceCalculator, IRuleset, IScoreInfo, ReplayFrame, IConvertibleReplayFrame, LegacyReplayFrame, ReplayConverter, IReplayFrame, HitResult, DifficultyRange, Ruleset } from 'osu-classes';

declare class StandardModCombination extends ModCombination {
  get mode(): number;
  protected get _availableMods(): IMod[];
}

declare abstract class StandardHitObject extends HitObject implements IHasPosition, IHasComboInformation {
  /**
   * The radius of hit objects (ie. the radius of a Circle).
   */
  static OBJECT_RADIUS: number;
  /**
   * Scoring distance with a speed-adjusted beat length of 1 second
   * (ie. the speed slider balls move through their track).
   */
  static BASE_SCORING_DISTANCE: number;
  /**
   * Minimum preempt time at AR=10.
   */
  static PREEMPT_MIN: number;
  timePreempt: number;
  timeFadeIn: number;
  private _scale;
  private _stackHeight;
  private _stackOffset;
  currentComboIndex: number;
  comboIndex: number;
  comboIndexWithOffsets: number;
  comboOffset: number;
  lastInCombo: boolean;
  isNewCombo: boolean;
  hitWindows: HitWindows;
  get endPosition(): Vector2;
  get endX(): number;
  set endX(value: number);
  get endY(): number;
  set endY(value: number);
  get scale(): number;
  set scale(value: number);
  get radius(): number;
  get stackHeight(): number;
  set stackHeight(value: number);
  get stackedOffset(): Vector2;
  set stackedOffset(value: Vector2);
  get stackedStartPosition(): Vector2;
  get stackedEndPosition(): Vector2;
  applyDefaultsToSelf(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  /**
   * Creates a deep copy of this standard hit object.
   * @returns Cloned standard hit object.
   */
  clone(): this;
}

declare class Circle extends StandardHitObject {
}

declare class SliderHead extends Circle {
}

declare abstract class SliderEnd extends Circle {
  protected _slider: Slider;
  repeatIndex: number;
  hitWindows: osu_classes.HitWindows;
  constructor(slider: Slider);
  get spanDuration(): number;
  applyDefaultsToSelf(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
}

declare class SliderTail extends SliderEnd {
}

declare class Slider extends StandardHitObject implements ISlidableObject {
  tickDistance: number;
  tickRate: number;
  velocity: number;
  legacyLastTickOffset?: number;
  /**
   * The position of the cursor at the point of completion of this slider if it was hit
   * with as few movements as possible. This is set and used by difficulty calculation.
   */
  lazyEndPosition?: Vector2;
  /**
   * The distance travelled by the cursor upon completion of this slider if it was hit
   * with as few movements as possible. This is set and used by difficulty calculation.
   */
  lazyTravelDistance: number;
  /**
   * The time taken by the cursor upon completion of this slider if it was hit
   * with as few movements as possible. This is set and used by difficulty calculation.
   */
  lazyTravelTime: number;
  hitWindows: osu_classes.HitWindows;
  path: SliderPath;
  nodeSamples: HitSample[][];
  repeats: number;
  startPosition: Vector2;
  get startX(): number;
  set startX(value: number);
  get startY(): number;
  set startY(value: number);
  get endX(): number;
  set endX(value: number);
  get endY(): number;
  set endY(value: number);
  get head(): SliderHead | null;
  get tail(): SliderTail | null;
  get distance(): number;
  set distance(value: number);
  get spans(): number;
  get spanDuration(): number;
  get duration(): number;
  get endPosition(): Vector2;
  get endTime(): number;
  applyDefaultsToSelf(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  createNestedHitObjects(): void;
  private _updateHeadPosition;
  private _updateTailPosition;
  /**
   * Creates a deep copy of this slider.
   * @returns Cloned slider.
   */
  clone(): this;
}

declare class SliderRepeat extends SliderEnd {
}

declare class SliderTick extends StandardHitObject {
  spanIndex: number;
  spanStartTime: number;
  hitWindows: osu_classes.HitWindows;
  applyDefaultsToSelf(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  /**
   * Creates a deep copy of this slider tick.
   * @returns Cloned slider tick.
   */
  clone(): this;
}

declare class Spinner extends StandardHitObject implements ISpinnableObject {
  /**
   * Spinning doesn't match 1:1 with stable,
   * so let's fudge them easier for the time being.
   */
  static STABLE_MATCHING_FUDGE: number;
  /**
   * Close to 477rpm.
   */
  static MAXIMUM_ROTATIONS: number;
  /**
   * Number of spins required to finish the spinner without miss.
   */
  spinsRequired: number;
  /**
   * Number of spins available to give bonus, beyond spinsRequired.
   */
  maximumBonusSpins: number;
  /**
   * The time at which this spinner ends.
   */
  endTime: number;
  hitWindows: osu_classes.HitWindows;
  get duration(): number;
  applyDefaultsToSelf(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  createNestedHitObjects(): void;
  clone(): this;
}

declare class SpinnerTick extends StandardHitObject {
  hitWindows: osu_classes.HitWindows;
}

declare class SpinnerBonusTick extends SpinnerTick {
}

declare class StandardEventGenerator extends EventGenerator {
  static generateSliderTicks(slider: Slider): Generator<StandardHitObject>;
  static generateSpinnerTicks(spinner: Spinner): Generator<StandardHitObject>;
}

declare class StandardBeatmap extends RulesetBeatmap {
  mods: StandardModCombination;
  hitObjects: StandardHitObject[];
  get mode(): number;
  get maxCombo(): number;
  /**
   * A list of circles of this beatmap.
   */
  get circles(): Circle[];
  /**
   * A list of sliders of this beatmap.
   */
  get sliders(): Slider[];
  /**
   * A list of spinners of this beatmap.
   */
  get spinners(): Spinner[];
}

declare class StandardBeatmapConverter extends BeatmapConverter {
  canConvert(beatmap: IBeatmap): boolean;
  convertHitObjects(beatmap: IBeatmap): Generator<StandardHitObject>;
  private _convertHitObject;
  private _convertCircle;
  private _convertSlider;
  private _convertSpinner;
  private _copyProperties;
  createBeatmap(): StandardBeatmap;
}

declare class StandardBeatmapProcessor extends BeatmapProcessor {
  private static readonly STACK_DISTANCE;
  postProcess(beatmap: StandardBeatmap): StandardBeatmap;
  private _applyStackingNew;
  private _applyStackingOld;
}

declare class StandardDifficultyAttributes extends DifficultyAttributes {
  /**
   * The difficulty corresponding to the aim skill.
   */
  aimDifficulty: number;
  /**
   * The difficulty corresponding to the speed skill.
   */
  speedDifficulty: number;
  /**
   * The number of clickable objects weighted by difficulty.
   * Related to {@link speedDifficulty}.
   */
  speedNoteCount: number;
  /**
   * The difficulty corresponding to the flashlight skill.
   */
  flashlightDifficulty: number;
  /**
   * Describes how much of {@link aimDifficulty} is contributed to by hitcircles or sliders.
   * A value closer to 1.0 indicates most of {@link aimDifficulty} is contributed by hitcircles.
   * A value closer to 0.0 indicates most of {@link aimDifficulty} is contributed by sliders.
   */
  sliderFactor: number;
  /**
   * The perceived approach rate inclusive of rate-adjusting mods (DT/HT/etc).
   * Rate-adjusting mods don't directly affect the approach rate difficulty value,
   * but have a perceived effect as a result of adjusting audio timing.
   */
  approachRate: number;
  /**
   * The perceived overall difficulty inclusive of rate-adjusting mods (DT/HT/etc).
   * Rate-adjusting mods don't directly affect the overall difficulty value,
   * but have a perceived effect as a result of adjusting audio timing.
   */
  overallDifficulty: number;
  /**
   * The beatmap's drain rate. This doesn't scale with rate-adjusting mods.
   */
  drainRate: number;
  /**
   * The number of hitcircles in the beatmap.
   */
  hitCircleCount: number;
  /**
   * The number of sliders in the beatmap.
   */
  sliderCount: number;
  /**
   * The number of spinners in the beatmap.
   */
  spinnerCount: number;
}

declare class StandardAutopilot implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare class StandardAutoplay extends Autoplay {
}

declare class StandardCinema extends Cinema {
}

declare class StandardDoubleTime extends DoubleTime {
}

declare class StandardEasy extends Easy {
}

declare class StandardFlashlight extends Flashlight$1 {
}

declare class StandardHalfTime extends HalfTime {
}

declare class StandardHardRock extends HardRock implements IApplicableToHitObjects {
  static BASE_SIZE: Vector2;
  applyToHitObjects(hitObjects: StandardHitObject[]): void;
  private static _reflectVertically;
}

declare class StandardHidden extends Hidden implements IApplicableToBeatmap {
  static readonly FADE_IN_DURATION_MULTIPLIER = 0.4;
  static readonly FADE_OUT_DURATION_MULTIPLIER = 0.3;
  applyToBeatmap(beatmap: StandardBeatmap): void;
  private _applyFadeAdjustments;
}

declare class StandardNightcore extends Nightcore {
}

declare class StandardNoFail extends NoFail {
}

declare class StandardNoMod extends NoMod {
}

declare class StandardPerfect extends Perfect {
}

declare class StandardRelax extends Relax {
}

declare class StandardSpunOut implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare class StandardSuddenDeath extends SuddenDeath {
}

declare class StandardTouchDevice implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare class StandardPerformanceAttributes extends PerformanceAttributes {
  /**
   * The mods which were applied to the beatmap.
   */
  mods: StandardModCombination;
  /**
   * The aim performance of a score.
   */
  aimPerformance: number;
  /**
   * The speed performance of a score.
   */
  speedPerformance: number;
  /**
   * The accuracy performance of a score.
   */
  accuracyPerformance: number;
  /**
   * The flashlight performance of a score.
   */
  flashlightPerformance: number;
  /**
   * Effective miss count.
   */
  effectiveMissCount: number;
  /**
   * Creates new difficulty attributes.
   * @param mods The mods which were applied to the beatmap.
   * @param totalPerformance The total performance of a score.
   */
  constructor(mods: StandardModCombination, totalPerformance: number);
}

declare class StandardDifficultyHitObject extends DifficultyHitObject {
  /**
   * A distance by which all distances should be scaled in order to assume a uniform circle size.
   */
  private static readonly NORMALIZED_RADIUS;
  private static readonly MIN_DELTA_TIME;
  private static readonly MAXIMUM_SLIDER_RADIUS;
  private static readonly ASSUMED_SLIDER_RADIUS;
  /**
   * Milliseconds elapsed since the start time of the previous
   * {@link StandardDifficultyHitObject}, with a minimum of 25ms.
   */
  readonly strainTime: number;
  /**
   * Normalized distance from the end position of the previous
   * {@link StandardDifficultyHitObject} to the start position of this {@link StandardDifficultyHitObject}.
   * The "lazy" end position is the position at which the cursor ends up if the previous hitobject
   * is followed with as minimal movement as possible (i.e. on the edge of slider follow circles).
   */
  lazyJumpDistance: number;
  /**
   * Normalised shortest distance to consider for a jump between the previou
   * {@link StandardDifficultyHitObject} and this {@link StandardDifficultyHitObject}.
   * This is bounded from above by {@link lazyJumpDistance}, and is smaller than the former
   * if a more natural path is able to be taken through the previous {@link StandardDifficultyHitObject}.
   */
  minimumJumpDistance: number;
  /**
   * The time taken to travel through {@link minimumJumpDistance}, with a minimum of 25ms.
   */
  minimumJumpTime: number;
  /**
   * Normalised distance between the start and end position of this {@link StandardDifficultyHitObject}.
   */
  travelDistance: number;
  /**
   * The time taken to travel through {@link travelDistance}, with a minimum value of 25ms {@link Slider} objects.
   */
  travelTime: number;
  /**
   * Angle the player has to take to hit this {@link StandardDifficultyHitObject}.
   * Calculated as the angle between the circles (current-2, current-1, current).
   */
  angle: number | null;
  /**
   * Retrieves the full hit window for a Great {@link HitResult}.
   */
  hitWindowGreat: number;
  readonly baseObject: StandardHitObject;
  readonly lastObject: StandardHitObject;
  private readonly _lastLastObject;
  constructor(hitObject: IHitObject, lastObject: IHitObject, lastLastObject: IHitObject | null, clockRate: number, objects: StandardDifficultyHitObject[], index: number);
  opacityAt(time: number, hidden: boolean): number;
  private _setDistances;
  private _computeSliderCursorPosition;
  private _getEndCursorPosition;
}

declare abstract class StandardStrainSkill extends StrainSkill {
  /**
   * The default multiplier applied by {@link StandardStrainSkill}
   * to the final difficulty value after all other calculations.
   */
  static DEFAULT_DIFFICULTY_MULTIPLIER: number;
  /**
   * The number of sections with the highest strains,
   * which the peak strain reductions will apply to.
   * This is done in order to decrease their impact
   * on the overall difficulty of the map for this skill.
   */
  protected _reducedSectionCount: number;
  /**
   * The baseline multiplier applied to the section with the biggest strain.
   */
  protected _reducedStrainBaseline: number;
  /**
   * The final multiplier to be applied to difficulty value after all other calculations.
   */
  protected _difficultyMultiplier: number;
  get difficultyValue(): number;
}

/**
 * Represents the skill required to correctly aim at every object
 * in the map with a uniform CircleSize and normalized distances.
 */
declare class Aim extends StandardStrainSkill {
  private static readonly SKILL_MULTIPLIER;
  private static readonly STRAIN_DECAY_BASE;
  private _currentStrain;
  private readonly _withSliders;
  constructor(mods: StandardModCombination, withSliders: boolean);
  private _strainDecay;
  protected _calculateInitialStrain(time: number, current: DifficultyHitObject): number;
  protected _strainValueAt(current: DifficultyHitObject): number;
}

/**
 * Represents the skill required to memorise and hit every object in a map with the Flashlight mod enabled.
 */
declare class Flashlight extends StrainSkill {
  private static readonly SKILL_MULTIPLIER;
  private static readonly STRAIN_DECAY_BASE;
  private _currentStrain;
  private readonly _hasHiddenMod;
  constructor(mods: StandardModCombination);
  private _strainDecay;
  protected _calculateInitialStrain(time: number, current: DifficultyHitObject): number;
  protected _strainValueAt(current: DifficultyHitObject): number;
  get difficultyValue(): number;
}

/**
 * Represents the skill required to press keys with regards
 * to keeping up with the speed at which objects need to be hit.
 */
declare class Speed extends StandardStrainSkill {
  private static readonly SKILL_MULTIPLIER;
  private static readonly STRAIN_DECAY_BASE;
  private _currentStrain;
  private _currentRhythm;
  protected _reducedSectionCount: number;
  protected _difficultyMultiplier: number;
  private readonly _objectStrains;
  private _strainDecay;
  protected _calculateInitialStrain(time: number, current: DifficultyHitObject): number;
  protected _strainValueAt(current: DifficultyHitObject): number;
  relevantNoteCount(): number;
}

declare class StandardDifficultyCalculator extends DifficultyCalculator<StandardDifficultyAttributes> {
  private _DIFFICULTY_MULTIPLIER;
  protected _createDifficultyAttributes(beatmap: IBeatmap, mods: StandardModCombination, skills: Skill[], clockRate: number): StandardDifficultyAttributes;
  protected _createDifficultyHitObjects(beatmap: IBeatmap, clockRate: number): StandardDifficultyHitObject[];
  protected _createSkills(_: IBeatmap, mods: StandardModCombination): Skill[];
  get difficultyMods(): IMod[];
}

declare class StandardPerformanceCalculator extends PerformanceCalculator {
  static readonly PERFORMANCE_BASE_MULTIPLIER = 1.14;
  attributes?: StandardDifficultyAttributes;
  private _mods;
  private _scoreMaxCombo;
  private _countGreat;
  private _countOk;
  private _countMeh;
  private _countMiss;
  private _accuracy;
  private _effectiveMissCount;
  constructor(ruleset: IRuleset, attributes?: DifficultyAttributes, score?: IScoreInfo);
  calculateAttributes(attributes?: StandardDifficultyAttributes, score?: IScoreInfo): StandardPerformanceAttributes;
  private _computeAimValue;
  private _computeSpeedValue;
  private _computeAccuracyValue;
  private _computeFlashlightValue;
  private _calculateEffectiveMissCount;
  private _addParams;
  private _getComboScalingFactor;
  private get _totalHits();
}

declare enum StandardAction {
  /**
   * Left keyboard button or left mouse button.
   */
  LeftButton = 0,
  /**
   * Right keyboard button or right mouse button.
   */
  RightButton = 1,
  /**
   * Smoke button.
   */
  Smoke = 2
}

declare class StandardReplayFrame extends ReplayFrame implements IConvertibleReplayFrame {
  /**
   * Mouse position of this replay frame.
   */
  position: Vector2;
  /**
   * Button actions of this replay frame.
   */
  actions: Set<StandardAction>;
  fromLegacy(currentFrame: LegacyReplayFrame): this;
  toLegacy(): LegacyReplayFrame;
}

/**
 * osu!std replay converter.
 */
declare class StandardReplayConverter extends ReplayConverter {
  protected _createConvertibleReplayFrame(): StandardReplayFrame;
  protected _isConvertedReplayFrame(frame: IReplayFrame): boolean;
}

declare class StandardHitWindows extends HitWindows {
  private static readonly OSU_RANGES;
  isHitResultAllowed(result: HitResult): boolean;
  protected _getRanges(): DifficultyRange[];
}

/**
 * osu!std ruleset.
 */
declare class StandardRuleset extends Ruleset {
  /**
   * osu!std ruleset ID.
   */
  get id(): number;
  /**
   * Applies osu!std ruleset to a beatmap.
   * @param beatmap The beatmap.
   * @returns A new osu!std beatmap with applied ruleset.
   */
  applyToBeatmap(beatmap: IBeatmap): StandardBeatmap;
  /**
   * Applies osu!std ruleset and mods to a beatmap.
   * @param beatmap The beatmap.
   * @param mods osu!std mod combination.
   * @returns A new osu!std beatmap with applied mods.
   */
  applyToBeatmapWithMods(beatmap: IBeatmap, mods?: StandardModCombination): StandardBeatmap;
  /**
   * Resets a mod combination from a beatmap.
   * @param beatmap The beatmap.
   * @returns A new beatmap with no mods.
   */
  resetMods(beatmap: IBeatmap): StandardBeatmap;
  /**
   * Creates a new mod combination by converting legacy mod bitwise.
   * @param input Mod bitwise or acronyms.
   * @returns A new mod combination.
   */
  createModCombination(input?: number | string): StandardModCombination;
  /**
   * @returns A new osu!std beatmap processor.
   */
  protected _createBeatmapProcessor(): StandardBeatmapProcessor;
  /**
   * @returns A new osu!std beatmap converter.
   */
  protected _createBeatmapConverter(): StandardBeatmapConverter;
  /**
   * @returns A new osu!std replay converter.
   */
  protected _createReplayConverter(): StandardReplayConverter;
  /**
   * @param beatmap The beatmap for which the calculation will be done.
   * @returns A new osu!std difficulty calculator.
   */
  createDifficultyCalculator(beatmap: IBeatmap): StandardDifficultyCalculator;
  /**
   * @param attributes The difficulty attributes.
   * @param score Score information.
   * @returns A new osu!std performance calculator.
   */
  createPerformanceCalculator(attributes?: StandardDifficultyAttributes, score?: IScoreInfo): StandardPerformanceCalculator;
}

export { Aim, Circle, Flashlight, Slider, SliderEnd, SliderHead, SliderRepeat, SliderTail, SliderTick, Speed, Spinner, SpinnerBonusTick, SpinnerTick, StandardAction, StandardAutopilot, StandardAutoplay, StandardBeatmap, StandardBeatmapConverter, StandardBeatmapProcessor, StandardCinema, StandardDifficultyAttributes, StandardDifficultyCalculator, StandardDifficultyHitObject, StandardDoubleTime, StandardEasy, StandardEventGenerator, StandardFlashlight, StandardHalfTime, StandardHardRock, StandardHidden, StandardHitObject, StandardHitWindows, StandardModCombination, StandardNightcore, StandardNoFail, StandardNoMod, StandardPerfect, StandardPerformanceAttributes, StandardPerformanceCalculator, StandardRelax, StandardReplayConverter, StandardReplayFrame, StandardRuleset, StandardSpunOut, StandardStrainSkill, StandardSuddenDeath, StandardTouchDevice };
