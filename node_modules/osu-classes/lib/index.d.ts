/**
 * A color that supports RGBA format.
 */
declare class Color4 {
  /**
     * The red value of the color in range from 0 to 255.
     * @default 255
     */
  red: number;
  /**
     * The green value of the color in range from 0 to 255.
     * @default 255
     */
  green: number;
  /**
     * The blue value of the color in range from 0 to 255.
     * @default 255
     */
  blue: number;
  /**
     * The alpha value of the color in range from 0 to 1.
     * @default 1
     */
  alpha: number;
  /**
     * Creates a new color.
     * @param red Red value of the color in range from 0 to 255.
     * @param green Green value of the color in range from 0 to 255.
     * @param blue Blue value of the color in range from 0 to 255.
     * @param alpha Alpha value of the color in range from 0 to 1.
     */
  constructor(red?: number, green?: number, blue?: number, alpha?: number);
  /**
     * The HEX representation of the color.
     */
  get hex(): string;
  /**
     * @param color Another color.
     * @returns Wheter the color equals to another one.
     */
  equals(color: Color4): boolean;
  /**
     * Clones the current color.
     * @returns A cloned color.
     */
  clone(): Color4;
  /**
     * @returns A string representation of this color.
     */
  toString(): string;
}

declare class Vector2 {
  /**
     * The X-position.
     */
  x: number;
  /**
     * The Y-position.
     */
  y: number;
  /**
     * Creates a new instance of a Vector2.
     * @param x The X-position.
     * @param y The Y-position.
     */
  constructor(x: number, y?: number);
  get floatX(): number;
  get floatY(): number;
  /**
     * Adds a vector to the current and returns a new instance.
     * @param vec Vector to add.
     */
  add(vec: Vector2): Vector2;
  /**
     * Adds a vector to the current and
     * returns a new instance with single precision.
     * @param vec Vector to add.
     */
  fadd(vec: Vector2): Vector2;
  /**
     * Subtracts a vector from the current and returns a new instance.
     * @param vec Vector to substract.
     */
  subtract(vec: Vector2): Vector2;
  /**
     * Subtracts a vector from the current and
     * returns a new instance with single precision.
     * @param vec Vector to substract.
     */
  fsubtract(vec: Vector2): Vector2;
  /**
     * Scales the current vector and returns a new instance.
     * @param multiplier Vector multiplier.
     */
  scale(multiplier: number): Vector2;
  /**
     * Scales the current vector and
     * returns a new instance with single precision.
     * @param vec Vector to substract.
     */
  fscale(multiplier: number): Vector2;
  /**
     * Divides the current vector and returns a new instance.
     * @param divisor Vector divisor.
     */
  divide(divisor: number): Vector2;
  /**
     * Subtracts a vector from the current and
     * returns a new instance with single precision.
     * @param vec Vector to substract.
     */
  fdivide(divisor: number): Vector2;
  /**
     * Returns a dot product of two vectors.
     * @param vec Second vector.
     */
  dot(vec: Vector2): number;
  /**
     * Returns a dot product of two vectors with single precision.
     * @param vec Second vector.
     */
  fdot(vec: Vector2): number;
  /**
     * Returns a length of two points in a vector.
     */
  length(): number;
  /**
     * Returns a single precision length of two points in a vector.
     */
  flength(): number;
  /**
     * Returns a distance between two vectors.
     * @param vec Second vector.
     */
  distance(vec: Vector2): number;
  fdistance(vec: Vector2): number;
  /**
     * Returns a normalized vector.
     */
  normalize(): Vector2;
  /**
     * Returns a normalized vector with single precision.
     */
  fnormalize(): Vector2;
  /**
     * Returns if two vectors are equal.
     * @param vec Second vector.
     */
  equals(vec: Vector2): boolean;
  /**
     * Clones the current vector.
     * @returns A cloned vector.
     */
  clone(): Vector2;
  /**
     * @returns A string representation of this vector.
     */
  toString(): string;
}

/**
 * A beatmap colors section.
 */
declare class BeatmapColorSection {
  /**
     * Additive combo colors.
     */
  comboColors: Color4[];
  /**
     * Additive slider track color.
     */
  sliderTrackColor?: Color4;
  /**
     * Slider border color.
     */
  sliderBorderColor?: Color4;
  /**
     * Creates a copy of this beatmap colors section.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): BeatmapColorSection;
}

declare class BeatmapDifficultySection {
  /**
     * The default value used for all difficulty settings
     * except slider multiplier and slider tickrate.
     */
  static BASE_DIFFICULTY: number;
  protected _CS: number;
  protected _HP: number;
  protected _OD: number;
  protected _AR?: number;
  protected _multiplier: number;
  protected _tickRate: number;
  protected _rate: number;
  /**
     * The circle size of this beatmap.
     */
  get circleSize(): number;
  set circleSize(value: number);
  /**
     * The HP drain rate of this beatmap.
     */
  get drainRate(): number;
  set drainRate(value: number);
  /**
     * The overall difficulty of this beatmap.
     */
  get overallDifficulty(): number;
  set overallDifficulty(value: number);
  /**
     * The approach rate of this beatmap.
     */
  get approachRate(): number;
  set approachRate(value: number);
  /**
     * The slider multiplier of this beatmap.
     */
  get sliderMultiplier(): number;
  set sliderMultiplier(value: number);
  /**
     * The slider tickrate of this beatmap.
     */
  get sliderTickRate(): number;
  set sliderTickRate(value: number);
  /**
     * The current state of this beatmap's clock rate.
     */
  get clockRate(): number;
  set clockRate(value: number);
  /**
     * Creates a copy of this beatmap difficulty section.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): BeatmapDifficultySection;
  /**
     * Maps a difficulty value [0, 10] to a two-piece linear range of values.
     * @param diff The difficulty value to be mapped.
     * @param min Minimum of the resulting range which will be achieved by a difficulty value of 0.
     * @param mid Midpoint of the resulting range which will be achieved by a difficulty value of 5.
     * @param max Maximum of the resulting range which will be achieved by a difficulty value of 10.
     * @returns Value to which the difficulty value maps in the specified range.
     */
  static range(diff: number, min: number, mid: number, max: number): number;
}

/**
 * A beatmap editor section.
 */
declare class BeatmapEditorSection {
  /**
     * Time in milliseconds of bookmarks.
     */
  bookmarks: number[];
  /**
     * Distance snap multiplier.
     */
  distanceSpacing: number;
  /**
     * Beat snap divisor.
     */
  beatDivisor: number;
  /**
     * Grid size.
     */
  gridSize: number;
  /**
     * Scale factor for the object timeline.
     */
  timelineZoom: number;
  /**
     * Creates a copy of this beatmap editor section.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): BeatmapEditorSection;
}

/**
 * Types of storyboard layers.
 */
declare enum LayerType {
  Background = 0,
  Fail = 1,
  Pass = 2,
  Foreground = 3,
  Overlay = 4,
  Video = 5
}

/**
 * Origins of the storyboard sprite.
 */
declare enum Anchor {
  /**
     * The vertical counterpart is at "Top" position.
     */
  y0 = 1,
  /**
     * The vertical counterpart is at "Centre" position.
     */
  y1 = 2,
  /**
     * The vertical counterpart is at "Bottom" position.
     */
  y2 = 4,
  /**
     * The horizontal counterpart is at "Left" position.
     */
  x0 = 8,
  /**
     * The horizontal counterpart is at "Centre" position.
     */
  x1 = 16,
  /**
     * The horizontal counterpart is at "Right" position.
     */
  x2 = 32,
  /**
     * The user is manually updating the outcome.
     */
  Custom = 64,
  TopLeft = 9,
  TopCentre = 17,
  TopRight = 33,
  CentreLeft = 10,
  Centre = 18,
  CentreRight = 34,
  BottomLeft = 12,
  BottomCentre = 20,
  BottomRight = 36
}

/**
 * Types of storyboard commands.
 */
declare enum CommandType {
  None = '',
  Movement = 'M',
  MovementX = 'MX',
  MovementY = 'MY',
  Fade = 'F',
  Scale = 'S',
  VectorScale = 'V',
  Rotation = 'R',
  Color = 'C',
  Parameter = 'P'
}

/**
 * Types of storyboard compounds.
 */
declare enum CompoundType {
  None = '',
  Loop = 'L',
  Trigger = 'T'
}

/**
 * Types of storyboard events.
 */
declare enum EventType {
  Background = 0,
  Video = 1,
  Break = 2,
  Colour = 3,
  Sprite = 4,
  Sample = 5,
  Animation = 6,
  StoryboardCommand = 7
}

/**
 * Types of animation loops.
 */
declare enum LoopType {
  LoopForever = 0,
  LoopOnce = 1
}

/**
 * This is used by osu!lazer to convert legacy origins to the new format.
 */
declare enum Origins {
  TopLeft = 0,
  Centre = 1,
  CentreLeft = 2,
  TopRight = 3,
  BottomCentre = 4,
  TopCentre = 5,
  Custom = 6,
  CentreRight = 7,
  BottomLeft = 8,
  BottomRight = 9
}

/**
 * Types of the parameter command.
 */
declare enum ParameterType {
  None = '',
  HorizontalFlip = 'H',
  VerticalFlip = 'V',
  BlendingMode = 'A'
}

/**
 * Types of easing.
 */
declare enum EasingType {
  None = 0,
  Out = 1,
  In = 2,
  InQuad = 3,
  OutQuad = 4,
  InOutQuad = 5,
  InCubic = 6,
  OutCubic = 7,
  InOutCubic = 8,
  InQuart = 9,
  OutQuart = 10,
  InOutQuart = 11,
  InQuint = 12,
  OutQuint = 13,
  InOutQuint = 14,
  InSine = 15,
  OutSine = 16,
  InOutSine = 17,
  InExpo = 18,
  OutExpo = 19,
  InOutExpo = 20,
  InCirc = 21,
  OutCirc = 22,
  InOutCirc = 23,
  InElastic = 24,
  OutElastic = 25,
  OutElasticHalf = 26,
  OutElasticQuarter = 27,
  InOutElastic = 28,
  InBack = 29,
  OutBack = 30,
  InOutBack = 31,
  InBounce = 32,
  OutBounce = 33,
  InOutBounce = 34,
  OutPow10 = 35
}

type EasingFn = (p: number) => number;
declare const linear: EasingFn;
declare const inQuad: EasingFn;
declare const outQuad: EasingFn;
declare const inOutQuad: EasingFn;
declare const inCubic: EasingFn;
declare const outCubic: EasingFn;
declare const inOutCubic: EasingFn;
declare const inQuart: EasingFn;
declare const outQuart: EasingFn;
declare const inOutQuart: EasingFn;
declare const inQuint: EasingFn;
declare const outQuint: EasingFn;
declare const inOutQuint: EasingFn;
declare const inSine: EasingFn;
declare const outSine: EasingFn;
declare const inOutSine: EasingFn;
declare const inExpo: EasingFn;
declare const outExpo: EasingFn;
declare const inOutExpo: EasingFn;
declare const inCirc: EasingFn;
declare const outCirc: EasingFn;
declare const inOutCirc: EasingFn;
declare const inElastic: EasingFn;
declare const outElastic: EasingFn;
declare const outElasticHalf: EasingFn;
declare const outElasticQuarter: EasingFn;
declare const inOutElastic: EasingFn;
declare const inBack: EasingFn;
declare const outBack: EasingFn;
declare const inOutBack: EasingFn;
declare const inBounce: EasingFn;
declare const outBounce: EasingFn;
declare const inOutBounce: EasingFn;
declare const outPow10: EasingFn;
declare function getEasingFn(easing: EasingType): EasingFn;

type Easing_EasingFn = EasingFn;
declare const Easing_linear: typeof linear;
declare const Easing_inQuad: typeof inQuad;
declare const Easing_outQuad: typeof outQuad;
declare const Easing_inOutQuad: typeof inOutQuad;
declare const Easing_inCubic: typeof inCubic;
declare const Easing_outCubic: typeof outCubic;
declare const Easing_inOutCubic: typeof inOutCubic;
declare const Easing_inQuart: typeof inQuart;
declare const Easing_outQuart: typeof outQuart;
declare const Easing_inOutQuart: typeof inOutQuart;
declare const Easing_inQuint: typeof inQuint;
declare const Easing_outQuint: typeof outQuint;
declare const Easing_inOutQuint: typeof inOutQuint;
declare const Easing_inSine: typeof inSine;
declare const Easing_outSine: typeof outSine;
declare const Easing_inOutSine: typeof inOutSine;
declare const Easing_inExpo: typeof inExpo;
declare const Easing_outExpo: typeof outExpo;
declare const Easing_inOutExpo: typeof inOutExpo;
declare const Easing_inCirc: typeof inCirc;
declare const Easing_outCirc: typeof outCirc;
declare const Easing_inOutCirc: typeof inOutCirc;
declare const Easing_inElastic: typeof inElastic;
declare const Easing_outElastic: typeof outElastic;
declare const Easing_outElasticHalf: typeof outElasticHalf;
declare const Easing_outElasticQuarter: typeof outElasticQuarter;
declare const Easing_inOutElastic: typeof inOutElastic;
declare const Easing_inBack: typeof inBack;
declare const Easing_outBack: typeof outBack;
declare const Easing_inOutBack: typeof inOutBack;
declare const Easing_inBounce: typeof inBounce;
declare const Easing_outBounce: typeof outBounce;
declare const Easing_inOutBounce: typeof inOutBounce;
declare const Easing_outPow10: typeof outPow10;
declare const Easing_getEasingFn: typeof getEasingFn;
declare namespace Easing {
  export {
    Easing_EasingFn as EasingFn,
    Easing_linear as linear,
    Easing_inQuad as inQuad,
    Easing_outQuad as outQuad,
    Easing_inOutQuad as inOutQuad,
    Easing_inCubic as inCubic,
    Easing_outCubic as outCubic,
    Easing_inOutCubic as inOutCubic,
    Easing_inQuart as inQuart,
    Easing_outQuart as outQuart,
    Easing_inOutQuart as inOutQuart,
    Easing_inQuint as inQuint,
    Easing_outQuint as outQuint,
    Easing_inOutQuint as inOutQuint,
    Easing_inSine as inSine,
    Easing_outSine as outSine,
    Easing_inOutSine as inOutSine,
    Easing_inExpo as inExpo,
    Easing_outExpo as outExpo,
    Easing_inOutExpo as inOutExpo,
    Easing_inCirc as inCirc,
    Easing_outCirc as outCirc,
    Easing_inOutCirc as inOutCirc,
    Easing_inElastic as inElastic,
    Easing_outElastic as outElastic,
    Easing_outElasticHalf as outElasticHalf,
    Easing_outElasticQuarter as outElasticQuarter,
    Easing_inOutElastic as inOutElastic,
    Easing_inBack as inBack,
    Easing_outBack as outBack,
    Easing_inOutBack as inOutBack,
    Easing_inBounce as inBounce,
    Easing_outBounce as outBounce,
    Easing_inOutBounce as inOutBounce,
    Easing_outPow10 as outPow10,
    Easing_getEasingFn as getEasingFn,
  };
}

/**
 * A storyboard command.
 */
declare class Command<T = any> {
  /**
     * Command type.
     */
  type: CommandType;
  /**
     * Command type.
     */
  parameter: ParameterType;
  /**
     * The easing of the storyboard command.
     */
  easing: EasingType;
  /**
     * The time at which the command starts.
     */
  startTime: number;
  /**
     * The time at which the command ends.
     */
  endTime: number;
  /**
     * Starting value of this command.
     */
  startValue: T;
  /**
     * Ending value of this command.
     */
  endValue: T;
  constructor(params?: Partial<Command>);
  /**
     * The duration of the storyboard command.
     */
  get duration(): number;
  /**
     * Calculates the progress of this command.
     * @param time Current time in milliseconds.
     * @returns Progress of this command in range from 0 to 1.
     */
  getProgress(time: number): number;
  /**
     * Calculates the value of this command at a given progress.
     * @param progress Current progress in range from 0 to 1.
     * @returns Calculated value.
     */
  getValueAtProgress(progress: number): T;
  /**
     * Calculates the value of this command at a given momemnt of time.
     * @param time Current time in milliseconds.
     * @returns Calculated value.
     */
  getValueAtTime(time: number): T;
  /**
     * @param other Other storyboard command.
     * @returns If two storyboard commands are equal.
     */
  equals(other: Command<T>): boolean;
}

/**
 * A storyboard command timeline.
 */
declare class CommandTimeline<T = any> implements Iterable<Command<T>> {
  private readonly _commands;
  startTime: number;
  endTime: number;
  startValue: T;
  endValue: T;
  [Symbol.iterator](): Iterator<Command<T>>;
  /**
     * A command list.
     */
  get commands(): Command<T>[];
  add(type: CommandType, easing: EasingType, startTime: number, endTime: number, startValue: T, endValue: T, parameter?: ParameterType): void;
  get hasCommands(): boolean;
}

declare const enum BlendingEquation {
  /**
     * Inherits from parent.
     */
  Inherit = 0,
  /**
     * Adds the source and destination colors.
     */
  Add = 1,
  /**
     * Chooses the minimum of each component of the source and destination colors.
     */
  Min = 2,
  /**
     * Chooses the maximum of each component of the source and destination colors.
     */
  Max = 3,
  /**
     * Subtracts the destination color from the source color.
     */
  Subtract = 4,
  /**
     * Subtracts the source color from the destination color.
     */
  ReverseSubtract = 5
}

declare const enum BlendEquationMode {
  FuncAdd = 32774,
  Min = 32775,
  Max = 32776,
  FuncSubtract = 32778,
  FuncReverseSubtract = 32779
}

declare const enum BlendingFactorDest {
  Zero = 0,
  SrcColor = 768,
  OneMinusSrcColor = 769,
  SrcAlpha = 770,
  OneMinusSrcAlpha = 771,
  DstAlpha = 772,
  OneMinusDstAlpha = 773,
  DstColor = 774,
  OneMinusDstColor = 775,
  SrcAlphaSaturate = 776,
  ConstantColor = 32769,
  OneMinusConstantColor = 32770,
  ConstantAlpha = 32771,
  OneMinusConstantAlpha = 32772,
  One = 1
}

declare const enum BlendingFactorSrc {
  Zero = 0,
  SrcColor = 768,
  OneMinusSrcColor = 769,
  SrcAlpha = 770,
  OneMinusSrcAlpha = 771,
  DstAlpha = 772,
  OneMinusDstAlpha = 773,
  DstColor = 774,
  OneMinusDstColor = 775,
  SrcAlphaSaturate = 776,
  ConstantColor = 32769,
  OneMinusConstantColor = 32770,
  ConstantAlpha = 32771,
  OneMinusConstantAlpha = 32772,
  One = 1
}

/**
 * Types of blending.
 */
declare enum BlendingMode {
  AdditiveBlending = 0,
  AlphaBlending = 1
}

/**
 * Types of blending.
 */
declare const enum BlendingType {
  Inherit = 0,
  ConstantAlpha = 1,
  ConstantColor = 2,
  DstAlpha = 3,
  DstColor = 4,
  One = 5,
  OneMinusConstantAlpha = 6,
  OneMinusConstantColor = 7,
  OneMinusDstAlpha = 8,
  OneMinusDstColor = 9,
  OneMinusSrcAlpha = 10,
  OneMinusSrcColor = 11,
  SrcAlpha = 12,
  SrcAlphaSaturate = 13,
  SrcColor = 14,
  Zero = 15
}

/**
 * Contains information about how a drawable should be blended into its destination.
 */
declare class BlendingParameters {
  /**
     * The blending factor for the source color of the blend.
     */
  source: BlendingType;
  /**
     * The blending factor for the destination color of the blend.
     */
  destination: BlendingType;
  /**
     * The blending factor for the source alpha of the blend.
     */
  sourceAlpha: BlendingType;
  /**
     * The blending factor for the destination alpha of the blend.
     */
  destinationAlpha: BlendingType;
  /**
     * Gets or sets the blending equation to use for the RGB components of the blend.
     */
  rgbEquation: BlendingEquation;
  /**
     * Gets or sets the blending equation to use for the alpha component of the blend.
     */
  alphaEquation: BlendingEquation;
  static None: BlendingParameters;
  static Inherit: BlendingParameters;
  static Mixture: BlendingParameters;
  static Additive: BlendingParameters;
  constructor(params: Partial<BlendingParameters>);
  /**
     * Copy all properties that are marked as inherited from a parent blending parameters object.
     * @param parent The parent blending parameters from which to copy inherited properties.
     */
  copyFromParent(parent: BlendingParameters): void;
  /**
     * Any properties marked as inherited will have their
     * blending mode changed to the default type.
     * This can occur when a root element is set to inherited.
     */
  applyDefaultToInherited(): void;
  equals(other: BlendingParameters): boolean;
  get isDisabled(): boolean;
  /**
     * Gets the blending equation mode for the currently specified RGB Equation.
     */
  get rgbEquationMode(): BlendEquationMode;
  /**
     * Gets the blending equation mode for the currently specified Alpha Equation.
     */
  get alphaEquationMode(): BlendEquationMode;
  /**
     * Gets the blending factor source for the currently specified source blending mode.
     */
  get sourceBlendingFactor(): BlendingFactorSrc;
  /**
     * Gets the blending factor destination for the currently specified destination blending mode.
     */
  get destinationBlendingFactor(): BlendingFactorDest;
  /**
     * Gets the blending factor source for the currently specified source alpha mode.
     */
  get sourceAlphaBlendingFactor(): BlendingFactorSrc;
  /**
     * Gets the blending factor destination for the currently specified destination alpha mode.
     */
  get destinationAlphaBlendingFactor(): BlendingFactorDest;
  private static _translateBlendingFactorSrc;
  private static _translateBlendingFactorDest;
  private static _translateEquation;
}

/**
 * A command timeline group.
 */
declare class CommandTimelineGroup {
  x: CommandTimeline<number>;
  y: CommandTimeline<number>;
  scale: CommandTimeline<number>;
  vectorScale: CommandTimeline<Vector2>;
  rotation: CommandTimeline<number>;
  color: CommandTimeline<Color4>;
  alpha: CommandTimeline<number>;
  blendingParameters: CommandTimeline<BlendingParameters>;
  flipH: CommandTimeline<boolean>;
  flipV: CommandTimeline<boolean>;
  readonly _timelines: CommandTimeline[];
  constructor();
  get timelines(): CommandTimeline[];
  get totalCommands(): number;
  get commands(): Command[];
  get commandsStartTime(): number;
  get commandsEndTime(): number;
  get commandsDuration(): number;
  get startTime(): number;
  get endTime(): number;
  get duration(): number;
  get hasCommands(): boolean;
}

/**
 * A storyboard command loop.
 */
declare class CommandLoop extends CommandTimelineGroup {
  /**
     * Compound type.
     */
  type: CompoundType;
  /**
     * The start time of the loop.
     */
  loopStartTime: number;
  /**
     * The total number of repeats.
     */
  loopCount: number;
  /**
     * Creates a new instance of the storyboard command loop.
     * @param loopStartTime The start time of the loop.
     * @param loopCount The number of repeats of this loop.
     */
  constructor(loopStartTime?: number, loopCount?: number);
  /**
     * The total number of times this loop is played back. Always greater than zero.
     */
  get totalIterations(): number;
  /**
     * The start time of the command loop.
     */
  get startTime(): number;
  /**
     * The end time of the command loop.
     */
  get endTime(): number;
  unrollCommands(): Command[];
}

declare class CommandTrigger extends CommandTimelineGroup {
  /**
     * Compound type.
     */
  type: CompoundType;
  /**
     * The name of the trigger.
     */
  triggerName: string;
  /**
     * The start time of the command trigger.
     */
  triggerStartTime: number;
  /**
     * The end time of the command trigger.
     */
  triggerEndTime: number;
  /**
     * The group of the command trigger.
     */
  groupNumber: number;
  /**
     * Creates a new instance of command trigger.
     * @param triggerName The name of the trigger.
     * @param startTime The start time of the command trigger.
     * @param endTime The end time of the command trigger.
     * @param groupNumber The group of the command trigger.
     */
  constructor(triggerName?: string, startTime?: number, endTime?: number, groupNumber?: number);
  unrollCommands(): Command[];
}

/**
 * A storyboard element.
 */
interface IStoryboardElement {
  /**
     * The start time of the storyboard element.
     */
  startTime: number;
  /**
     * The file path of the content of the storyboard element.
     */
  filePath: string;
  /**
     * Whether this storyboard element can be drawn or not.
     */
  isDrawable: boolean;
}

/**
 * A storyboard element that has commands.
 */
interface IHasCommands extends IStoryboardElement {
  /**
     * The list of commands of the storyboard element.
     * This is not synchronized with {@link timelineGroup}
     * as constantly updating it can be very expensive.
     * If you need to update this array, use {@link updateCommands}.
     */
  commands: Command[];
  /**
     * The command timeline group of this storyboard element.
     */
  timelineGroup: CommandTimelineGroup;
  /**
     * The list of command loops of the storyboard element.
     */
  loops: CommandLoop[];
  /**
     * The list of command triggers of the storyboard element.
     */
  triggers: CommandTrigger[];
  /**
     * Collects all commands from every timeline and loop.
     * All loop commands are unwinded, which means there is no need to iterate over loops.
     * This method also updates {@link commands} array.
     * @returns General command array of this sprite.
     */
  updateCommands(): Command[];
  /**
     * If this storyboard element has commands or not.
     */
  hasCommands: boolean;
}

/**
 * A storyboard element that ends at a different time than its start time.
 */
interface IStoryboardElementWithDuration extends IStoryboardElement {
  /**
     * The time at which this storyboard element ends.
     */
  endTime: number;
  /**
     * The duration of the storyboard element.
     */
  duration: number;
}

/**
 * A storyboard sprite.
 */
declare class StoryboardSprite implements IStoryboardElementWithDuration, IHasCommands {
  /**
     * The origin of the image on the screen.
     */
  origin: Origins;
  /**
     * The anchor of the image on the screen.
     */
  anchor: Anchor;
  /**
     * The start time of the storyboard sprite.
     */
  startTime: number;
  /**
     * The end time of the storyboard sprite.
     */
  endTime: number;
  /**
     * The file path of the content of this storyboard sprite.
     */
  filePath: string;
  /**
     * The list of commands of the storyboard element.
     * This is not synchronized with {@link timelineGroup}
     * as constantly updating it can be very expensive.
     * If you need to update this array, use {@link updateCommands}.
     */
  commands: Command[];
  /**
     * The list of commands of the storyboard sprite.
     */
  timelineGroup: CommandTimelineGroup;
  /**
     * The list of command loops of the storyboard sprite.
     */
  loops: CommandLoop[];
  /**
     * The list of command triggers of the storyboard sprite.
     */
  triggers: CommandTrigger[];
  /**
     * The relative start position of the storyboard sprite.
     */
  startPosition: Vector2;
  /**
     * Current scale of this sprite.
     */
  scale: Vector2;
  /**
     * Current color of this sprite.
     */
  color: Color4;
  /**
     * Current rotation of this sprite.
     */
  rotation: number;
  /**
     * If this sprite is fliped horizontally.
     */
  flipX: boolean;
  /**
     * If this sprite is fliped vertically.
     */
  flipY: boolean;
  /**
     * If this sprite is using additive blending.
     */
  isAdditive: boolean;
  /**
     * @param path The file path of the content of this storyboard sprite.
     * @param origin The origin of the image on the screen.
     * @param anchor The anchor of the image on the screen.
     * @param position The relative start position of the storyboard sprite.
     * @constructor
     */
  constructor(path: string, origin: Origins, anchor: Anchor, position: Vector2);
  /**
     * The start X-position of the storyboard sprite.
     */
  get startX(): number;
  set startX(value: number);
  /**
     * The start Y-position of the storyboard sprite.
     */
  get startY(): number;
  set startY(value: number);
  get duration(): number;
  get hasCommands(): boolean;
  get isDrawable(): boolean;
  /**
     * Creates a new instance of the storyboard command loop.
     * @param startTime The start time of the loop.
     * @param repeatCount The number of repeats of this loop.
     */
  addLoop(startTime: number, repeatCount: number): CommandLoop;
  /**
     * Creates a new instance of command trigger.
     * @param triggerName The name of the trigger.
     * @param startTime The start time of the command trigger.
     * @param endTime The end time of the command trigger.
     * @param groupNumber The group of the command trigger.
     */
  addTrigger(triggerName: string, startTime: number, endTime: number, groupNumber: number): CommandTrigger;
  /**
     * Collects all commands from every timeline and loop.
     * All loop commands are unwinded, which means there is no need to iterate over loops.
     * This method also updates {@link commands} array.
     * @returns General command array of this sprite.
     */
  updateCommands(): Command[];
  /**
     * Adjusts start & end time of this sprite to the
     * earliest command start time & latest command end time.
     */
  adjustTimesToCommands(): void;
  /**
     * Resets all sprite values to first applied command values.
     */
  resetValuesToCommands(): void;
  /**
     * Replaces current sprite values with command values.
     * @param command Target command.
     * @param progress Current command progress.
     */
  setValueFromCommand(command: Command, progress: number): void;
}

/**
 * A storyboard animation.
 */
declare class StoryboardAnimation extends StoryboardSprite {
  /**
     * The number of frames in this animation.
     */
  frameCount: number;
  /**
     * The delay (in milliseconds) between each frame of the animation.
     */
  frameDelay: number;
  /**
     * Indicates if the animation should loop or not.
     */
  loopType: LoopType;
  /**
     * @param path The file path of the content of this storyboard sprite.
     * @param origin The origin of the image on the screen.
     * @param anchor The anchor of the image on the screen.
     * @param position The relative start position of the storyboard sprite.
     * @param frameCount The number of frames in this animation.
     * @param frameDelay The delay (in milliseconds) between each frame of the animation.
     * @param loopType Indicates if the animation should loop or not.
     * @constructor
     */
  constructor(path: string, origin: Origins, anchor: Anchor, position: Vector2, frameCount: number, frameDelay: number, loopType: LoopType);
}

/**
 * A storyboard sample.
 */
declare class StoryboardSample implements IStoryboardElement {
  /**
     * The start time of the storyboard sample.
     */
  startTime: number;
  /**
     * The volume of the storyboard sample.
     */
  volume: number;
  /**
     * The file path of the sound of this sample.
     */
  filePath: string;
  get isDrawable(): boolean;
  constructor(path: string, time: number, volume: number);
}

/**
 * A storyboard video.
 */
declare class StoryboardVideo implements IStoryboardElement {
  /**
     * The start time of the storyboard video.
     */
  startTime: number;
  /**
     * The file path of this video.
     */
  filePath: string;
  get isDrawable(): boolean;
  constructor(path: string, time: number);
}

/**
 * A storyboard layer.
 */
declare class StoryboardLayer {
  /**
     * Storyboard layer name.
     */
  readonly name: string;
  /**
     * Storyboard layer name.
     */
  readonly depth: number;
  /**
     * Should this layer be masked or not?
     */
  readonly masking: boolean;
  /**
     * Is this layer visible when player is alive.
     */
  visibleWhenPassing: boolean;
  /**
     * Is this layer visible when player fails.
     */
  visibleWhenFailing: boolean;
  /**
     * Storyboard layer elements.
     */
  elements: IStoryboardElement[];
  constructor(params: Required<Pick<StoryboardLayer, 'name' | 'depth'>> & Partial<StoryboardLayer>);
}

/**
 * A beatmap storyboard.
 */
declare class Storyboard {
  /**
     * Variables of the storyboard.
     */
  variables: Map<string, string>;
  /**
     * Custom beatmap colors.
     */
  colors: BeatmapColorSection;
  /**
     * Whether the storyboard can fall back to skin sprites
     * in case no matching storyboard sprites are found.
     */
  useSkinSprites: boolean;
  /**
     * Depth of the currently front-most storyboard layer, excluding the overlay layer.
     */
  minimumLayerDepth: number;
  /**
     * Beatmap file version for which this storyboard was created.
     */
  fileFormat: number;
  /**
     * Storyboard layers.
     */
  private _layers;
  constructor();
  get layers(): Map<string, StoryboardLayer>;
  get hasDrawable(): boolean;
  get hasVariables(): boolean;
  /**
     * Across all layers, find the earliest point in time that a storyboard element exists at.
     * Will return `null` if there are no elements.
     * This iterates all elements and as such should be used sparingly or stored locally.
     */
  get earliestEventTime(): number | null;
  /**
     * Across all layers, find the latest point in time that a storyboard element ends at.
     * Will return null if there are no elements.
     * This iterates all elements and as such should be used sparingly or stored locally.
     * Videos and samples return start time as their end time.
     */
  get latestEventTime(): number | null;
  /**
     * Adds a new storyboard layer.
     * @param layer A storyboard layer.
     */
  addLayer(layer: StoryboardLayer): void;
  /**
     * Finds a storyboard layer by its type. Returns background layer if type doesn't exist.
     * @param type The type of the storyboard layer.
     * @returns The storyboard layer.
     */
  getLayerByType(type: LayerType): StoryboardLayer;
  /**
     * Finds a storyboard layer by its name. Otherwise will create a new storyboard layer with this name.
     * @param name The name of the storyboard layer.
     * @returns The storyboard layer.
     */
  getLayerByName(name: string): StoryboardLayer;
}

/**
 * A beatmap break event.
 */
declare class BeatmapBreakEvent {
  /**
     * The time at which break event starts.
     */
  startTime: number;
  /**
     * The time at which break event ends.
     */
  endTime: number;
  /**
     * Creates a new instance of beatmap break event.
     * @param startTime The time at which break event starts.
     * @param endTime The time at which break event ends.
     */
  constructor(startTime: number, endTime: number);
  /**
     * The duration of this beatmap break event.
     */
  get duration(): number;
  /**
     * @returns Whether the beatmap break event has effects.
     */
  get hasEffect(): boolean;
  /**
     * @param time The time.
     * @returns Whether beatmap break lasts at the specified time.
     */
  contains(time: number): boolean;
}

/**
 * A beatmap events section.
 */
declare class BeatmapEventSection {
  /**
     * A beatmap background file path.
     */
  backgroundPath: string | null;
  /**
     * List of beatmap break events.
     */
  breaks: BeatmapBreakEvent[];
  /**
     * A beatmap storyboard.
     */
  storyboard: Storyboard | null;
  /**
     * Whether the storyboard replace the background?
     */
  get isBackgroundReplaced(): boolean;
  /**
     * Creates a copy of this beatmap events section.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): BeatmapEventSection;
}

/**
 * Types of sample set.
 */
declare enum SampleSet {
  None = 0,
  Normal = 1,
  Soft = 2,
  Drum = 3
}

/**
 * A beatmap general section.
 */
declare class BeatmapGeneralSection {
  /**
     * Location of the audio file relative to the current folder.
     */
  audioFilename: string;
  /**
     * @deprecated
     */
  audioHash?: string;
  /**
     * Draw order of hit circle overlays compared to hit numbers.
     *   NoChange = use skin setting.
     *   Below = draw overlays under numbers.
     *   Above = draw overlays on top of numbers.
     */
  overlayPosition: string;
  /**
     * Preferred skin to use during gameplay.
     */
  skinPreference: string;
  /**
     * Milliseconds of silence before the audio starts playing.
     */
  audioLeadIn: number;
  /**
     * Time in milliseconds when the audio preview should start.
     */
  previewTime: number;
  /**
     * Speed of the countdown before the first hit object.
     *   0 = no countdown.
     *   1 = normal.
     *   2 = half.
     *   3 = double.
     */
  countdown: number;
  /**
     * Multiplier for the threshold in time where
     * hit objects placed close together stack (0â€“1).
     */
  stackLeniency: number;
  /**
     * Time in beats that the countdown starts before the first hit object.
     */
  countdownOffset: number;
  /**
     * Sample set that will be used if timing points
     * do not override it (Normal, Soft, Drum).
     */
  sampleSet: SampleSet;
  /**
     * Whether or not breaks have a letterboxing effect.
     */
  letterboxInBreaks: boolean;
  /**
     * @deprecated
     */
  storyFireInFront?: boolean;
  /**
     * Whether or not the storyboard can use the user's skin images.
     */
  useSkinSprites: boolean;
  /**
     * @deprecated
     */
  alwaysShowPlayfield?: boolean;
  /**
     * Whether or not a warning about flashing colors
     * should be shown at the beginning of the map.
     */
  epilepsyWarning: boolean;
  /**
     * Whether or not the "N+1" style key layout is used for osu!mania.
     */
  specialStyle: boolean;
  /**
     * Whether or not the storyboard allows widescreen viewing.
     */
  widescreenStoryboard: boolean;
  /**
     * Whether or not sound samples will change
     * rate when playing with speed-changing mods.
     */
  samplesMatchPlaybackRate: boolean;
  /**
     * Creates a copy of this beatmap general section.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): BeatmapGeneralSection;
}

/**
 * A beatmap metadata section.
 */
declare class BeatmapMetadataSection {
  /**
     * Romanised song title.
     */
  title: string;
  /**
     * Romanised song artist.
     */
  artist: string;
  /**
     * Beatmap creator.
     */
  creator: string;
  /**
     * Difficulty name.
     */
  version: string;
  /**
     * Original media the song was produced for.
     */
  source: string;
  /**
     * Search terms.
     */
  tags: string[];
  /**
     * Beatmap ID.
     */
  beatmapId: number;
  /**
     * Beatmapset ID.
     */
  beatmapSetId: number;
  /**
     * Song title.
     */
  private _titleUnicode;
  get titleUnicode(): string;
  set titleUnicode(value: string);
  /**
     * Song artist.
     */
  private _artistUnicode;
  get artistUnicode(): string;
  set artistUnicode(value: string);
  /**
     * Creates a copy of this beatmap metadata section.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): BeatmapMetadataSection;
}

/**
 * A group of control points.
 */
declare class ControlPointGroup {
  /**
     * A list of control points.
     */
  controlPoints: ControlPoint[];
  /**
     * The time at which group starts.
     */
  startTime: number;
  /**
     * Creates a new group of control points.
     * @param time The time at which group starts.
     * @constructor
     */
  constructor(time: number);
  /**
     * Adds a new control point to a group.
     * @param point A control point.
     */
  add(point: ControlPoint): void;
  /**
     * Removes a control point from a group.
     * @param point A control point.
     */
  remove(point: ControlPoint): void;
}

/**
 * All types of control points.
 */
declare enum ControlPointType {
  TimingPoint = 0,
  DifficultyPoint = 1,
  EffectPoint = 2,
  SamplePoint = 3
}

/**
 * A control point of a beatmap.
 */
declare abstract class ControlPoint {
  abstract pointType: ControlPointType;
  /**
     * The group to which a control point belongs.
     */
  group: ControlPointGroup | null;
  /**
     * Creates a new instance of a control point.
     * @param group A group of this control point.
     * @constructor
     */
  constructor(group?: ControlPointGroup);
  /**
     * Attaches a new group to this control point.
     * @param group A new group.
     */
  attachGroup(group: ControlPointGroup): void;
  /**
     * Dettaches a group from this control point.
     */
  dettachGroup(): void;
  /**
     * The time at which control point starts.
     */
  get startTime(): number;
  abstract isRedundant(existing: ControlPoint | null): boolean;
}

/**
 * A difficulty point.
 */
declare class DifficultyPoint extends ControlPoint {
  /**
     * The default instance of a difficulty point.
     */
  static default: DifficultyPoint;
  /**
     * The type of a difficulty point.
     */
  pointType: ControlPointType;
  /**
     * Whether or not slider ticks should be generated at this control point.
     * This exists for backwards compatibility with maps that abuse
     * NaN slider velocity behavior on osu!stable (e.g. /b/2628991).
     */
  generateTicks: boolean;
  /**
     * Indicates whether this difficulty control point should be considered as legacy or not.
     */
  isLegacy: boolean;
  private _sliderVelocity;
  /**
     * The slider velocity at this difficulty point.
     */
  get sliderVelocity(): number;
  set sliderVelocity(value: number);
  /**
     * Legacy BPM multiplier that introduces floating-point
     * errors for rulesets that depend on it.
     * DO NOT USE THIS UNLESS 100% SURE.
     */
  bpmMultiplier: number;
  /**
     * Checks if this difficulty point is redundant to an another one.
     * @param existing The another difficulty point.
     * @returns Whether the difficulty point is redundant.
     */
  isRedundant(existing: DifficultyPoint | null): boolean;
  /**
     * @param other Other difficulty control point.
     * @returns If two difficulty control points are equal.
     */
  equals(other: DifficultyPoint): boolean;
}

/**
 * An effect point.
 */
declare class EffectPoint extends ControlPoint {
  /**
     * The default instance of an effect point.
     */
  static default: EffectPoint;
  /**
     * The type of an effect point.
     */
  pointType: ControlPointType;
  /**
     * Whether this control point enables kiai mode.
     */
  kiai: boolean;
  /**
     * Whether the first bar line of this control point is ignored.
     */
  omitFirstBarLine: boolean;
  /**
     * The relative scroll speed at this control point.
     */
  private _scrollSpeed;
  get scrollSpeed(): number;
  set scrollSpeed(value: number);
  /**
     * Checks if this effect point is redundant to an another one.
     * @param existing The another effect point.
     * @returns Whether the effect point is redundant.
     */
  isRedundant(existing: EffectPoint | null): boolean;
  /**
     * @param other Other effect control point.
     * @returns If two effect control points are equal.
     */
  equals(other: EffectPoint): boolean;
}

/**
 * A sample point.
 */
declare class SamplePoint extends ControlPoint {
  /**
     * The default instance of a sample point.
     */
  static default: SamplePoint;
  /**
     * The type of a sample point.
     */
  pointType: ControlPointType;
  /**
     * The sample bank of this sample point.
     */
  sampleSet: string;
  /**
     * The custom index of this sample point.
     */
  customIndex: number;
  /**
     * The volume of this sample point.
     */
  volume: number;
  /**
     * Checks if this sample point is redundant to an another one.
     * @param existing The another sample point.
     * @returns Whether the sample point is redundant.
     */
  isRedundant(existing: SamplePoint): boolean;
  /**
     * @param other Other sample control point.
     * @returns If two sample control points are equal.
     */
  equals(other: SamplePoint): boolean;
}

/**
 * All time signatures.
 */
declare enum TimeSignature {
  SimpleTriple = 3,
  SimpleQuadruple = 4
}

/**
 * A timing point.
 */
declare class TimingPoint extends ControlPoint {
  /**
     * The default instance of a timing point.
     */
  static default: TimingPoint;
  /**
     * The type of a timing point.
     */
  pointType: ControlPointType;
  /**
     * The beat length of this timing point.
     */
  private _beatLength;
  get beatLength(): number;
  set beatLength(value: number);
  /**
     * The time signature of this timing point.
     */
  timeSignature: TimeSignature;
  /**
     * The BPM of this timing point.
     */
  get bpm(): number;
  /**
     * Timing points are never redundant as they can change the time signature.
     */
  isRedundant(): false;
  /**
     * @param other Other timing control point.
     * @returns If two timing control points are equal.
     */
  equals(other: TimingPoint): boolean;
}

/**
 * The information about control points.
 */
declare class ControlPointInfo {
  /**
     * All groups of control points.
     */
  groups: ControlPointGroup[];
  /**
     * All difficulty points.
     */
  difficultyPoints: DifficultyPoint[];
  /**
     * All effect points.
     */
  effectPoints: EffectPoint[];
  /**
     * All sample points.
     */
  samplePoints: SamplePoint[];
  /**
     * All timing points.
     */
  timingPoints: TimingPoint[];
  /**
     * All control points.
     */
  get allPoints(): ControlPoint[];
  /**
     * Finds a group at the specified time.
     * @param time The time.
     * @returns A group at the specified time.
     */
  groupAt(time: number): ControlPointGroup;
  /**
     * Finds a difficulty point at the specified time.
     * @param time The time.
     * @returns A difficulty point at the specified time.
     */
  difficultyPointAt(time: number): DifficultyPoint;
  /**
     * Finds a effect point at the specified time.
     * @param time The time.
     * @returns A effect point at the specified time.
     */
  effectPointAt(time: number): EffectPoint;
  /**
     * Finds a sample point at the specified time.
     * @param time The time.
     * @returns A sample point at the specified time.
     */
  samplePointAt(time: number): SamplePoint;
  /**
     * Finds a timing point at the specified time.
     * @param time The time.
     * @returns A timing point at the specified time.
     */
  timingPointAt(time: number): TimingPoint;
  /**
     * Adds a new unique control point to the group at the specified time.
     * @param point A control point.
     * @param time The time.
     * @returns Whether the control point has been added to the group.
     */
  add(point: ControlPoint, time: number): boolean;
  getCurrentList(newPoint: ControlPoint): ControlPoint[];
  checkAlreadyExisting(time: number, newPoint: ControlPoint): boolean;
  /**
     * Removes a control point from the group at the specified time.
     * @param point A control point.
     * @param time The time.
     * @returns Whether the control point has been removed from the group.
     */
  remove(point: ControlPoint, time: number): boolean;
  /**
     * Removes all control points.
     */
  clear(): void;
  /**
     * Creates a copy of this information about control points.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied information about control points.
     */
  clone(): ControlPointInfo;
}

/**
 * Hit sound types.
 */
declare enum HitSound {
  None = 0,
  Normal = 1,
  Whistle = 2,
  Finish = 4,
  Clap = 8
}

/**
 * Hit types.
 */
declare enum HitType {
  Normal = 1,
  Slider = 2,
  NewCombo = 4,
  Spinner = 8,
  ComboSkip1 = 16,
  ComboSkip2 = 32,
  ComboSkip3 = 64,
  ComboOffset = 112,
  Hold = 128
}

/**
 * Slider curve types.
 */
declare enum PathType {
  Catmull = 'C',
  Bezier = 'B',
  Linear = 'L',
  PerfectCurve = 'P'
}

/**
 * Types of slider events.
 */
declare enum SliderEventType {
  Tick = 1,
  LegacyLastTick = 2,
  Head = 4,
  Tail = 8,
  Repeat = 16
}

/**
 * An object describing the name of a sound file,
 * which has the following format:
 *
 * <sampleSet>-hit<hitSound><index>.wav
 */
declare class HitSample {
  /**
     * The bank to load the sample from.
     */
  sampleSet: string;
  /**
     * Hit sound data.
     */
  hitSound: string;
  /**
     * Custom index of hit sample.
     */
  customIndex: number;
  /**
     * An optional suffix to provide priority lookup.
     * Falls back to non-suffixed name.
     */
  suffix: string;
  /**
     * The sample volume.
     */
  volume: number;
  /**
     * Whether this hit sample is layered.
     */
  isLayered: boolean;
  /**
     * The filename of this hit sample.
     */
  filename: string;
  /**
     * Creates a copy of this hit sample.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied hit sample.
     */
  clone(): HitSample;
}

declare enum HitResult {
  /**
     * Indicates that the object has not been judged yet.
     */
  None = 0,
  /**
     * Indicates that the object has been judged as a miss.
     * This miss window should determine how early a hit can be before it is considered
     * for judgement (as opposed to being ignored as "too far in the future").
     * It should also define when a forced miss should be triggered (as a result of no user input in time).
     */
  Miss = 1,
  Meh = 2,
  Ok = 3,
  Good = 4,
  Great = 5,
  Perfect = 6,
  /**
     * Indicates small tick miss.
     */
  SmallTickMiss = 7,
  /**
     * Indicates a small tick hit.
     */
  SmallTickHit = 8,
  /**
     * Indicates a large tick miss.
     */
  LargeTickMiss = 9,
  /**
     * Indicates a large tick hit.
     */
  LargeTickHit = 10,
  /**
     * Indicates a small bonus.
     */
  SmallBonus = 11,
  /**
     * Indicates a large bonus.
     */
  LargeBonus = 12,
  /**
     * Indicates a miss that should be ignored for scoring purposes.
     */
  IgnoreMiss = 13,
  /**
     * Indicates a hit that should be ignored for scoring purposes.
     */
  IgnoreHit = 14
}

declare class DifficultyRange {
  readonly result: HitResult;
  min: number;
  average: number;
  max: number;
  constructor(result: HitResult, min: number, average: number, max: number);
  /**
     * Maps a difficulty value [0, 10] to a two-piece linear range of values.
     * @param difficulty The difficulty value to be mapped.
     * @param min Minimum of the resulting range which will be achieved by a difficulty value of 0.
     * @param mid Midpoint of the resulting range which will be achieved by a difficulty value of 5.
     * @param max Maximum of the resulting range which will be achieved by a difficulty value of 10.
     * @returns Value to which the difficulty value maps in the specified range.
     */
  static map(difficulty: number, min: number, mid: number, max: number): number;
}

declare enum ScoreRank {
  F = -1,
  D = 0,
  C = 1,
  B = 2,
  A = 3,
  S = 4,
  SH = 5,
  X = 6,
  XH = 7
}

interface IJsonableHitStatistics {
  none?: number;
  miss?: number;
  meh?: number;
  ok?: number;
  good?: number;
  great?: number;
  perfect?: number;
  smallTickMiss?: number;
  smallTickHit?: number;
  largeTickMiss?: number;
  largeTickHit?: number;
  smallBonus?: number;
  largeBonus?: number;
  ignoreMiss?: number;
  ignoreHit?: number;
}

/**
 * A special case of a map structure for storing hit statistics.
 */
declare class HitStatistics extends Map<HitResult, number> {
  /**
     * Gets the number of hit results by their type.
     * If hit result is not present sets it to default value and returns it.
     * @param key Hit result type.
     * @returns The number of hit results of this type.
     */
  get(key: HitResult): number;
  /**
     * Converts this map to a readable JSON format.
     */
  toJSON(): IJsonableHitStatistics;
  static fromJSON(json: IJsonableHitStatistics): HitStatistics;
  private static _getJsonableKeyFromHitResult;
  private static _getHitResultFromJsonableKey;
}

/**
 * A structure containing timing data for hit window based gameplay.
 */
declare class HitWindows {
  private static readonly _BASE_RANGES;
  private _perfect;
  private _great;
  private _good;
  private _ok;
  private _meh;
  private _miss;
  /**
     * Retrieves the hit result with the largest hit window that produces a successful hit.
     * @returns The lowest allowed successful hit result.
     */
  protected _lowestSuccessfulHitResult(): HitResult;
  /**
     * Retrieves a mapping of hit results to their timing windows for all allowed hit results.
     */
  getAllAvailableWindows(): Generator<[HitResult, number]>;
  /**
     * Check whether it is possible to achieve the provided hit result.
     * @param result The result type to check.
     * @returns Whether the hit result can be achieved.
     */
  isHitResultAllowed(result: HitResult): boolean;
  /**
     * Sets hit windows with values that correspond to a difficulty parameter.
     * @param difficulty The parameter.
     */
  setDifficulty(difficulty: number): void;
  /**
     * Retrieves the hit result for a time offset.
     * @param timeOffset The time offset.
     * @returns The hit result, or HitResult.None if timeOffset doesn't result in a judgement.
     */
  resultFor(timeOffset: number): HitResult;
  /**
     * Retrieves the hit window for a hit result.
     * This is the number of +/- milliseconds allowed for the requested result
     * (so the actual hittable range is double this).
     * @param result The expected hit result.
     * @returns One half of the hit window for result.
     */
  windowFor(result: HitResult): number;
  /**
     * Given a time offset, whether the hit object can ever be hit in the future with a non-miss result.
     * This happens if time offset is less than what is required for lowest successful hit result.
     * @param timeOffset The time offset.
     * @returns Whether the hit object can be hit at any point in the future from this time offset.
     */
  canBeHit(timeOffset: number): boolean;
  /**
     * Retrieve a valid list of <see cref="DifficultyRange"/>s representing hit windows.
     * Defaults are provided but can be overridden to customise for a ruleset.
     */
  protected _getRanges(): DifficultyRange[];
  private static EmptyHitWindows;
  /**
     * An empty hit windows with only misses and perfects.
     * No time values are provided (meaning instantaneous hit or miss).
     */
  static empty: HitWindows;
}

declare enum ReplayButtonState {
  None = 0,
  Left1 = 1,
  Right1 = 2,
  Left2 = 4,
  Right2 = 8,
  Smoke = 16
}

/**
 * A life bar frame.
 */
interface ILifeBarFrame {
  /**
     * Starting time of this life bar frame.
     */
  startTime: number;
  /**
     * The amount of HP at that current time.
     * This value is in range of 0-1.
     */
  health: number;
  /**
     * Create a new copy of this life bar frame.
     * @returns A clone of life bar frame.
     */
  clone(): ILifeBarFrame;
}

/**
 * A replay frame.
 */
interface IReplayFrame {
  /**
     * Starting time of this replay frame.
     */
  startTime: number;
  /**
     * Interval between this and previous replay frames.
     */
  interval: number;
  /**
     * Create a new copy of this replay frame.
     * @returns A clone of replay frame.
     */
  clone(): IReplayFrame;
}

/**
 * A replay.
 */
interface IReplay {
  /**
     * osu! game version of this replay.
     */
  gameVersion: number;
  /**
     * Game mode of this replay.
     */
  mode: number;
  /**
     * Replay MD5 hash.
     */
  hashMD5: string;
  /**
     * Replay frames.
     */
  frames: IReplayFrame[];
  /**
     * Life bar of the replay.
     */
  lifeBar: ILifeBarFrame[];
}

/**
 * A replay frame.
 */
declare abstract class ReplayFrame implements IReplayFrame {
  /**
     * The time at which this {@link ReplayFrame} takes place.
     */
  startTime: number;
  /**
     * Interval between this and previous replay frames.
     */
  interval: number;
  constructor(startTime?: number, interval?: number);
  /**
     * Creates a deep copy of the replay frame.
     * @returns Cloned replay frame.
     */
  clone(): this;
}

/**
 * Parsed replay frame.
 */
declare class LegacyReplayFrame extends ReplayFrame {
  /**
     * Button state of this replay frame.
     */
  buttonState: ReplayButtonState;
  /**
     * Mouse position of this replay frame.
     */
  position: Vector2;
  constructor(startTime?: number, interval?: number, position?: Vector2, buttonState?: ReplayButtonState);
  /**
     * Mouse X-position of this replay frame.
     */
  get mouseX(): number;
  /**
     * Mouse Y-position of this replay frame.
     */
  get mouseY(): number;
  /**
     * Mouse position of this replay frame.
     */
  get mousePosition(): Vector2;
  get mouseLeft(): boolean;
  get mouseRight(): boolean;
  get mouseLeft1(): boolean;
  get mouseRight1(): boolean;
  get mouseLeft2(): boolean;
  get mouseRight2(): boolean;
  get smoke(): boolean;
  /**
     * Creates a deep copy of the replay frame.
     * @returns Cloned replay frame.
     */
  clone(): this;
}

/**
 * A life bar frame.
 */
declare class LifeBarFrame implements ILifeBarFrame {
  /**
     * Starting time of this life bar frame.
     */
  startTime: number;
  /**
     * The amount of HP at that current time.
     * This value is in range of 0-1.
     */
  health: number;
  constructor(startTime?: number, health?: number);
  /**
     * Creates a deep copy of the replay frame.
     * @returns Cloned replay frame.
     */
  clone(): this;
}

/**
 * A replay.
 */
declare class Replay implements IReplay {
  /**
     * osu! game version of this replay.
     */
  gameVersion: number;
  /**
     * Game mode of this replay.
     */
  mode: number;
  /**
     * Replay MD5 hash.
     */
  hashMD5: string;
  /**
     * Replay frames.
     */
  frames: ReplayFrame[];
  /**
     * Life bar of the replay.
     */
  lifeBar: LifeBarFrame[];
  /**
     * Replay length in milliseconds.
     */
  get length(): number;
  /**
     * Creates a deep copy of the replay.
     * @returns Cloned replay.
     */
  clone(): this;
  equals(other: IReplay): boolean;
}

/**
 * A type of {@link IReplayFrame} which can be converted from a {@link LegacyReplayFrame}.
 */
interface IConvertibleReplayFrame extends IReplayFrame {
  /**
     * Populates this {@link ReplayFrame} using values from a {@link LegacyReplayFrame}.
     * @param currentFrame The {@link LegacyReplayFrame} to extract values from.
     * @param beatmap The beatmap of the replay which is used to get some data.
     * @param lastFrame The last post-conversion {@link ReplayFrame},
     * used to fill in missing delta information. May be null.
     * @returns A reference to this replay frame.
     */
  fromLegacy(currentFrame: LegacyReplayFrame, lastFrame: IReplayFrame | null, beatmap?: IBeatmap): this;
  /**
     * Populates this {@link ReplayFrame} using values from a {@link LegacyReplayFrame}.
     * @param beatmap The beatmap of the replay which is used to get some data.
     * @returns A new instance of legacy replay frame.
     */
  toLegacy(beatmap?: IBeatmap): LegacyReplayFrame;
}

/**
 * A replay converter.
 */
declare abstract class ReplayConverter {
  /**
     * Converts any replay from one game mode to another.
     * @param original Any kind of a replay.
     * @returns The converted replay.
     */
  convertReplay(original: IReplay, beatmap?: IBeatmap): Replay;
  createReplay(): Replay;
  convertFrames(frames: IReplayFrame[], beatmap?: IBeatmap): Generator<ReplayFrame>;
  protected _convertFrame(frame: IReplayFrame, lastFrame: IReplayFrame | null, beatmap?: IBeatmap): ReplayFrame;
  /**
     * @returns A new instance of convertible replay frame.
     */
  protected abstract _createConvertibleReplayFrame(): IConvertibleReplayFrame | null;
  /**
     * @param frame A replay frame.
     * @returns If replay frame is already converted to this ruleset.
     */
  protected abstract _isConvertedReplayFrame(frame: IReplayFrame): boolean;
}

/**
 * Bitwise flags of all mods.
 */
declare enum ModBitwise {
  None = 0,
  NoFail = 1,
  Easy = 2,
  TouchDevice = 4,
  Hidden = 8,
  HardRock = 16,
  SuddenDeath = 32,
  DoubleTime = 64,
  Relax = 128,
  HalfTime = 256,
  Nightcore = 512,
  Flashlight = 1024,
  Autoplay = 2048,
  SpunOut = 4096,
  Relax2 = 8192,
  Perfect = 16384,
  Key4 = 32768,
  Key5 = 65536,
  Key6 = 131072,
  Key7 = 262144,
  Key8 = 524288,
  FadeIn = 1048576,
  Random = 2097152,
  Cinema = 4194304,
  Target = 8388608,
  Key9 = 16777216,
  KeyCoop = 33554432,
  Key1 = 67108864,
  Key3 = 134217728,
  Key2 = 268435456,
  ScoreV2 = 536870912,
  Mirror = 1073741824,
  KeyMod = 487555072,
  DifficultyDecrease = 258,
  DifficultyIncrease = 1616
}

/**
 * Types of mods.
 */
declare enum ModType {
  DifficultyReduction = 0,
  DifficultyIncrease = 1,
  Conversion = 2,
  Automation = 3,
  Fun = 4,
  System = 5
}

interface IMod {
  /**
     * The name of this mod.
     */
  name: string;
  /**
     * The shortened name of this mod.
     */
  acronym: string;
  /**
     * Bitwise number of this mod.
     */
  bitwise: ModBitwise;
  /**
     * The type of this mod.
     */
  type: ModType;
  /**
     * The score multiplier of this mod.
     */
  multiplier: number;
  /**
     * Returns if this mod is ranked.
     */
  isRanked: boolean;
  /**
     * Incompatible mods.
     */
  incompatibles: ModBitwise;
}

/**
 * Mod that applicable to the beatmap.
 */
interface IApplicableToBeatmap extends IMod {
  /**
     * Applies a mod to the specified beatmap.
     * @param beatmap A beatmap.
     */
  applyToBeatmap(beatmap: IBeatmap): void;
}

/**
 * Mod that applicable to the hit objects.
 */
interface IApplicableToHitObjects extends IMod {
  /**
     * Applies a mod to beatmap hit objects.
     * @param hitObjects Beatmap hit objects.
     */
  applyToHitObjects(hitObjects: IHitObject[]): void;
}

/**
 * Mod that applicable to the beatmap.
 */
interface IApplicableToDifficulty extends IMod {
  /**
     * Applies a mod to a beatmap difficulty.
     * @param difficulty A beatmap difficulty.
     */
  applyToDifficulty(difficulty: BeatmapDifficultySection): void;
}

declare abstract class Autoplay implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class Cinema implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class DoubleTime implements IMod, IApplicableToDifficulty {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
  applyToDifficulty(difficulty: BeatmapDifficultySection): void;
}

declare abstract class Easy implements IMod, IApplicableToDifficulty {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
  applyToDifficulty(difficulty: BeatmapDifficultySection): void;
}

declare abstract class Flashlight implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class HalfTime implements IMod, IApplicableToDifficulty {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
  applyToDifficulty(difficulty: BeatmapDifficultySection): void;
}

declare abstract class HardRock implements IMod, IApplicableToDifficulty {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
  applyToDifficulty(difficulty: BeatmapDifficultySection): void;
}

declare abstract class Hidden implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class Nightcore extends DoubleTime {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  incompatibles: ModBitwise;
}

declare abstract class NoFail implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class NoMod implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class Perfect implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class Relax implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

declare abstract class SuddenDeath implements IMod {
  name: string;
  acronym: string;
  bitwise: ModBitwise;
  type: ModType;
  multiplier: number;
  isRanked: boolean;
  incompatibles: ModBitwise;
}

/**
 * A ruleset beatmap.
 */
declare abstract class RulesetBeatmap extends Beatmap {
  /**
     * Beatmap max possible combo.
     */
  abstract get maxCombo(): number;
  /**
     * Applied mods of a beatmap.
     */
  abstract mods: ModCombination;
  /**
     * Creates a deep copy of this ruleset beatmap.
     * @returns Cloned ruleset beatmap.
     */
  clone(): this;
}

/**
 * A beatmap converter.
 */
declare abstract class BeatmapConverter {
  /**
     * Converts any beatmap from one game mode to another.
     * @param original Any kind of a beatmap.
     * @returns The converted beatmap.
     */
  convertBeatmap(beatmap: IBeatmap): RulesetBeatmap;
  abstract convertHitObjects(beatmap: IBeatmap): Generator<HitObject>;
  abstract createBeatmap(): RulesetBeatmap;
  abstract canConvert(beatmap: IBeatmap): boolean;
}

/**
 * Mod that applicable to the converter.
 */
interface IApplicableToConverter extends IMod {
  /**
     * Applies a mod to the specified converter.
     * @param converter A converter.
     */
  applyToConverter(converter: BeatmapConverter): void;
}

/**
 * A mod combination.
 */
declare abstract class ModCombination {
  private _mods;
  abstract get mode(): number;
  constructor(input?: number | string);
  /**
     * The list of all mods of this combination.
     */
  get all(): IMod[];
  /**
     * The list of mods that are applicable to the beatmap.
     */
  get beatmapMods(): IApplicableToBeatmap[];
  /**
     * The list of mods that are applicable to the beatmap hit objects.
     */
  get hitObjectMods(): IApplicableToHitObjects[];
  /**
     * The list of mods that are applicable to the beatmap difficulty.
     */
  get difficultyMods(): IApplicableToDifficulty[];
  /**
     * The list of mods that are applicable to the beatmap converter.
     */
  get converterMods(): IApplicableToConverter[];
  /**
     * The list of all mod names.
     */
  get names(): string[];
  /**
     * The list of all mod acronyms.
     */
  get acronyms(): string[];
  /**
     * Bitwise value of the mod combination.
     */
  get bitwise(): number;
  /**
     * Score multiplier of the mod combination.
     */
  get multiplier(): number;
  /**
     * Whether the mod combination is ranked.
     */
  get isRanked(): boolean;
  /**
     * Bitwise value of all mods incompatible with this mod combination.
     */
  get incompatibles(): number;
  /**
     * @param input The bitwise value or acronyms.
     * @returns If the mod combination contain all of the mods from this bitwise or acronyms.
     */
  has(input: number | string): boolean;
  /**
     * @param Mod Target mod class.
     * @returns If this mod combination has the target mod.
     */
  any(Mod: new () => IMod): boolean;
  /**
     * Finds all mods that are applicable to the beatmap by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns The list of all found mods.
     */
  beatmapModsAt(input: number | string): IApplicableToBeatmap[];
  /**
     * Finds a mod that is applicable to the beatmap by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns First found mod. Otherwise returns null.
     */
  beatmapModAt(input: number | string): IApplicableToBeatmap;
  /**
     * Finds all mods that are applicable to the beatmap hit objects by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns The list of all found mods.
     */
  hitObjectModsAt(input: number | string): IApplicableToHitObjects[];
  /**
     * Finds a mod that is applicable to the beatmap hit objects by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns First found mod. Otherwise returns null.
     */
  hitObjectModAt(input: number | string): IApplicableToHitObjects;
  /**
     * Finds all mods that are applicable to the beatmap difficulty by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns The list of all found mods.
     */
  difficultyModsAt(input: number | string): IApplicableToDifficulty[];
  /**
     * Finds a mod that is applicable to the beatmap difficulty by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns First found mod. Otherwise returns null.
     */
  difficultyModAt(input: number | string): IApplicableToDifficulty;
  /**
     * Finds all mods that are applicable to the beatmap converter by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns The list of all found mods.
     */
  converterModsAt(input: number | string): IApplicableToConverter[];
  /**
     * Finds a mod that is applicable to the beatmap converter by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns First found mod. Otherwise returns null.
     */
  converterModAt(input: number | string): IApplicableToConverter;
  /**
     * Finds mods by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns The list of all found mods.
     */
  modsAt(input: number | string): IMod[];
  /**
     * Finds a mod by bitwise value or acronyms.
     * @param input The bitwise value or acronyms.
     * @returns First found mod. Otherwise returns null.
     */
  modAt(input: number | string): IMod;
  /**
     * Converts this mod combination to a string.
     * @returns Stringified mod combination.
     */
  toString(): string;
  /**
     * Converts this mod combination to a string.
     * @returns Formatted mod combination that can be converted to JSON.
     */
  toJSON(): string;
  /**
     * Converts mod acronyms to a bitwise value.
     * @param input The mod acronyms.
     * @returns The bitwise value.
     */
  toBitwise(input: unknown): number;
  /**
     * Creates a new copy of this mod combination.
     */
  clone(): this;
  /**
     * Wheter the mods are equal or not.
     * @param other The other mod combination.
     */
  equals(other: ModCombination): boolean;
  protected get _availableMods(): IMod[];
}

/**
 * Describes the difficulty of a beatmap, as output by a difficulty calculator.
 */
declare abstract class DifficultyAttributes {
  /**
     * The mods which were applied to the beatmap.
     */
  mods: ModCombination;
  /**
     * The combined star rating of all skill.
     */
  starRating: number;
  /**
     * The maximum achievable combo.
     */
  maxCombo: number;
  /**
     * Creates new difficulty attributes.
     * @param mods The mods which were applied to the beatmap.
     * @param starRating The combined star rating of all skills.
     */
  constructor(mods: ModCombination, starRating: number);
}

/**
 * Describes the performance of a score, as output by a performance calculator.
 */
declare abstract class PerformanceAttributes {
  /**
     * The mods which were applied to the beatmap.
     */
  mods: ModCombination;
  /**
     * The total performance of a score.
     */
  totalPerformance: number;
  /**
     * Creates new difficulty attributes.
     * @param mods The mods which were applied to the beatmap.
     * @param totalPerformance The total performance of a score.
     */
  constructor(mods: ModCombination, totalPerformance: number);
}

/**
 * Wraps a DifficultyAttributes object and adds a time value for which the attribute is valid.
 */
declare class TimedDifficultyAttributes<T extends DifficultyAttributes> {
  /**
     * The non-clock-adjusted time value at which the attributes take effect.
     */
  readonly time: number;
  /**
     * The difficulty attributes.
     */
  readonly attributes: T;
  /**
     * Creates new timed difficulty attributes.
     * @param time The non-clock-adjusted time value at which the attributes take effect.
     * @param attributes The difficuty attributes.
     */
  constructor(time: number, attributes: T);
  compareTo(other: TimedDifficultyAttributes<T>): number;
}

/**
 * Wraps a hit object and provides additional information to be used for difficulty calculation.
 */
declare class DifficultyHitObject {
  /**
     * The index of this {@link DifficultyHitObject} in the list of all {@link DifficultyHitObject}s.
     */
  index: number;
  /**
     * The {@link IHitObject} this {@link DifficultyHitObject} wraps.
     */
  readonly baseObject: IHitObject;
  /**
     * The last hit object which occurs before {@link IHitObject}.
     */
  readonly lastObject: IHitObject;
  /**
     * Amount of time elapsed between {@link baseObject} and {@link lastObject}, adjusted by clockrate.
     */
  readonly deltaTime: number;
  /**
     * Clockrate adjusted start time of {@link baseObject}.
     */
  readonly startTime: number;
  /**
     * Clockrate adjusted end time of {@link baseObject}.
     */
  readonly endTime: number;
  private readonly _difficultyHitObjects;
  /**
     * Creates a new {@link DifficultyHitObject}.
     * @param hitObject The hit object which this {@link DifficultyHitObject} wraps.
     * @param lastObject The last hit object which occurs before hit object in the beatmap.
     * @param clockRate The rate at which the gameplay clock is run at.
     * @param objects The list of {@link DifficultyHitObject}s in the current map
     * @param index The index of this {@link DifficultyHitObject} in {@link objects} list.
     */
  constructor(hitObject: IHitObject, lastObject: IHitObject, clockRate: number, objects: DifficultyHitObject[], index: number);
  previous(backwardsIndex: number): DifficultyHitObject | null;
  next(forwardsIndex: number): DifficultyHitObject | null;
}

/**
 * A bare minimal abstract skill for fully custom skill implementations.
 * This class should be considered a "processing" class and not persisted.
 */
declare abstract class Skill {
  /**
     * Mods for use in skill calculations.
     */
  protected _mods: ModCombination;
  constructor(mods: ModCombination);
  /**
     * Process a {@link DifficultyHitObject}.
     * @param current The difficulty hit object to process.
     */
  abstract process(current: DifficultyHitObject): void;
  /**
     * Returns the calculated difficulty value representing
     * all difficulty hit objects that have been processed up to this point.
     */
  abstract get difficultyValue(): number;
}

/**
 * Used to processes strain values of {@link DifficultyHitObject}s,
 * keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing
 * the difficulty of hitting all the processed objects.
 */
declare abstract class StrainSkill extends Skill {
  /**
     * The weight by which each strain value decays.
     */
  protected _decayWeight: number;
  /**
     * The length of each strain section.
     */
  protected _sectionLength: number;
  /**
     * We also keep track of the peak strain level in the current section.
     */
  private _currentSectionPeak;
  private _currentSectionEnd;
  private readonly _strainPeaks;
  /**
     * @returns The strain value at difficulty hit object.
     * This value is calculated with or without respect to previous objects.
     */
  protected abstract _strainValueAt(current: DifficultyHitObject): number;
  /**
     * Process a difficulty hit object and update current strain values accordingly.
     */
  process(current: DifficultyHitObject): void;
  /**
     * Saves the current peak strain level to the list of strain peaks,
     * which will be used to calculate an overall difficulty.
     */
  private _saveCurrentPeak;
  /**
     * Sets the initial strain level for a new section.
     * @param time The beginning of the new section in milliseconds.
     * @param current The current hit object.
     */
  private _startNewSectionFrom;
  /**
     * Retrieves the peak strain at a point in time.
     * @param time The time to retrieve the peak strain at.
     * @param current The current hit object.
     * @returns The peak strain.
     */
  protected abstract _calculateInitialStrain(time: number, current: DifficultyHitObject): number;
  /**
     * Returns a live enumerable of the peak strains
     * for each "section length" section of the beatmap,
     * including the peak of the current section.
     */
  getCurrentStrainPeaks(): Generator<number>;
  /**
     * Returns the calculated difficulty value representing
     * all difficulty hit objects that have been processed up to this point.
     */
  get difficultyValue(): number;
}

/**
 * Used to processes strain values of difficulty hit objects,
 * keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing
 * the difficulty of hitting all the processed objects.
 */
declare abstract class StrainDecaySkill extends StrainSkill {
  /**
     * Strain values are multiplied by this number for the given skill.
     * Used to balance the value of different skills between each other.
     */
  protected abstract _skillMultiplier: number;
  /**
     * Determines how quickly strain decays for the given skill.
     * For example a value of 0.15 indicates
     * that strain decays to 15% of its original value in one second.
     */
  protected abstract _strainDecayBase: number;
  /**
     * The current strain level.
     */
  protected _currentStrain: number;
  protected _calculateInitialStrain(time: number, current: DifficultyHitObject): number;
  protected _strainValueAt(current: DifficultyHitObject): number;
  /**
     * Calculates the strain value of a {@link DifficultyHitObject}.
     * This value is affected by previously processed objects.
     */
  protected abstract _strainValueOf(current: DifficultyHitObject): number;
  private _strainDecay;
}

declare abstract class DifficultyCalculator<T extends DifficultyAttributes = DifficultyAttributes> {
  /**
     * The beatmap for which difficulty will be calculated.
     */
  protected _beatmap: IBeatmap;
  protected _ruleset: IRuleset;
  protected _mods: ModCombination;
  constructor(beatmap: IBeatmap, ruleset: IRuleset);
  /**
     * Calculates the difficulty of the beatmap with no mods applied.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns A structure describing the difficulty of the beatmap.
     */
  calculate(clockRate?: number): T;
  /**
     * Calculates the difficulty of the beatmap using
     * all mod combinations applicable to the beatmap.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns A collection of structures describing
     * the difficulty of the beatmap for each mod combination.
     */
  calculateAll(clockRate?: number): Generator<T>;
  /**
     * Calculates the difficulty of the beatmap using a specific mod combination.
     * @param mods The mods that should be applied to the beatmap.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns A structure describing the difficulty of the beatmap.
     */
  calculateWithMods(mods: ModCombination, clockRate?: number): T;
  /**
     * Calculates the difficulty of the beatmap at a specific object count.
     * @param objectCount How many objects to use for calculation?
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns Difficulty attributes at the specific object count.
     */
  calculateAt(objectCount?: number, clockRate?: number): T;
  /**
     * Calculates the difficulty of the beatmap with applied mods at a sepcific object count.
     * @param mods The mods that should be applied to the beatmap.
     * @param objectCount How many objects to use for calculation?
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns Difficulty attributes at the specific object count.
     */
  calculateWithModsAt(mods: ModCombination, objectCount?: number, clockRate?: number): T;
  /**
     * Calculates the difficulty of the beatmap with no mods applied
     * and returns a set of timed difficulty attributes
     * representing the difficulty at every relevant time value in the beatmap.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns The set of timed difficulty attributes.
     */
  calculateTimed(clockRate?: number): Generator<TimedDifficultyAttributes<T>>;
  /**
     * Calculates the difficulty of the beatmap using a specific mod combination
     * and returns a set of timed difficulty attributes representing
     * the difficulty at every relevant time value in the beatmap.
     * @param mods The mods that should be applied to the beatmap.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns The set of timed difficulty attributes.
     */
  calculateTimedWithMods(mods: ModCombination, clockRate?: number): Generator<TimedDifficultyAttributes<T>>;
  /**
     * Creates a new copy of a beatmap and applies ruleset & mods to it.
     * @param mods The mods that should be applied to the beatmap.
     * @returns The properly converted beatmap.
     */
  private _getWorkingBeatmap;
  /**
     * @param beatmap The beatmap for creating difficulty hit objects.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns The difficulty hit objects to calculate against.
     */
  private _getDifficultyHitObjects;
  /**
     * Sorts a given set of difficulty hit objects.
     * @param input The difficulty hit objects to sort.
     * @returns The sorted difficulty hit objects.
     */
  protected _sortObjects(input: DifficultyHitObject[]): DifficultyHitObject[];
  /**
     * Creates all mod combinations which adjust the beatmap difficulty.
     */
  protected _createDifficultyModCombinations(): Generator<ModCombination>;
  get difficultyMods(): IMod[];
  /**
     * Creates difficulty attributes to describe beatmap's calculated difficulty.
     * @param beatmap The IBeatmap whose difficulty was calculated.
     * This may differ from Beatmap in the case of timed calculation.
     * @param mods The mods that difficulty was calculated with.
     * @param skills The skills which processed the beatmap.
     * @param clockRate Custom clock rate for the difficulty calculation.
     */
  protected abstract _createDifficultyAttributes(beatmap: IBeatmap, mods: ModCombination, skills: Skill[], clockRate: number): T;
  /**
     * Enumerates difficulty hit objects to be processed from hit objects in the IBeatmap.
     * @param beatmap The IBeatmap providing the hit objects to enumerate.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns The enumerated difficulty hit objects.
     */
  protected abstract _createDifficultyHitObjects(beatmap: IBeatmap, clockRate: number): DifficultyHitObject[];
  /**
     * Creates the Skills to calculate the difficulty of an IBeatmap.
     * @param beatmap The IBeatmap whose difficulty will be calculated.
     * This may differ from Beatmap in the case of timed calculation.
     * @param mods The mods to calculate difficulty with.
     * @param clockRate Custom clock rate for the difficulty calculation.
     * @returns The skills.
     */
  protected abstract _createSkills(beatmap: IBeatmap, mods: ModCombination, clockRate: number): Skill[];
}

declare abstract class PerformanceCalculator {
  readonly attributes?: DifficultyAttributes;
  protected readonly _ruleset: IRuleset;
  protected readonly _score?: IScoreInfo;
  constructor(ruleset: IRuleset, attributes?: DifficultyAttributes, score?: IScoreInfo);
  /**
     * Calculates total performance of a score by using difficulty attributes of a beatmap.
     * @param attributes Difficulty attributes.
     * @param score Score information.
     * @returns Total performance of a score.
     */
  calculate(attributes?: DifficultyAttributes, score?: IScoreInfo): number;
  /**
     * Calculates performance attributes of a score by using difficulty attributes of a beatmap.
     * @param attributes Difficulty attributes.
     * @param score Score information.
     * @returns Performance attributes of a score.
     */
  abstract calculateAttributes(attributes?: DifficultyAttributes, score?: IScoreInfo): PerformanceAttributes;
}

/**
 * An indexed queue with limited capacity.
 * Respects first-in-first-out insertion order.
 */
declare class LimitedCapacityQueue<T> {
  /**
     * The number of elements in the queue.
     */
  count: number;
  private readonly _array;
  private readonly _capacity;
  /**
     * Markers tracking the queue's first and last element.
     */
  private _start;
  private _end;
  /**
     * Constructs a new LimitedCapacityQueue.
     * @param capacity The number of items the queue can hold.
     */
  constructor(capacity: number);
  /**
     * Whether the queue is full (adding any new items will cause removing existing ones).
     */
  get full(): boolean;
  /**
     * Removes all elements from the queue.
     */
  clear(): void;
  /**
     * Removes an item from the front of the queue.
     * @returns The item removed from the front of the queue.
     */
  dequeue(): T;
  /**
     * Adds an item to the back of the queue.
     * If the queue is holding maximum elements at the point of addition,
     * the item at the front of the queue will be removed.
     * @param item The item to be added to the back of the queue.
     */
  enqueue(item: T): void;
  /**
     * Retrieves the item at the given index in the queue.
     * @param index  The index of the item to retrieve.
     * The item with index 0 is at the front of the queue (it was added the earliest).
     */
  get(index: number): T;
  /**
     * Enumerates the queue from its start to its end.
     * @returns An enumerator which enumerates items in the queue.
     */
  enumerate(): Generator<T>;
}

/**
 * An indexed queue where items are indexed beginning from the most recently enqueued item.
 * Enqueuing an item pushes all existing indexes up by one and inserts the item at index 0.
 * Dequeuing an item removes the item from the highest index and returns it.
 */
declare class ReverseQueue<T> {
  /**
     * The number of elements in the queue.
     */
  count: number;
  private _items;
  private _capacity;
  private _start;
  constructor(initialCapacity: number);
  /**
     * Retrieves the item at an index in the queue.
     * @param index The index of the item to retrieve.
     * The most recently enqueued item is at index 0.
     */
  get(index: number): T;
  /**
     * Enqueues an item to this queue.
     * @param item The item to enqueue.
     */
  enqueue(item: T): void;
  /**
     * Dequeues the least recently enqueued item from the queue and returns it.
     * @returns The item dequeued from the queue.
     */
  dequeue(): T;
  /**
     * Clears the queue of all items.
     */
  clear(): void;
  /**
     * Enumerates the queue starting from the most recently enqueued item.
     * @returns An enumerator which enumerates items in the queue.
     */
  enumerate(): Generator<T>;
}

/**
 * A ruleset.
 */
interface IRuleset {
  /**
     * Ruleset ID.
     */
  id: number;
  /**
     * Applies ruleset to a beatmap.
     * @param beatmap The beatmap.
     * @returns A new instance of the beatmap with applied ruleset.
     */
  applyToBeatmap(beatmap: IBeatmap): RulesetBeatmap;
  /**
     * Applies ruleset and mods to a beatmap.
     * @param beatmap The beatmap.
     * @param mods Mod combination.
     * @returns A new beatmap with applied mods.
     */
  applyToBeatmapWithMods(beatmap: IBeatmap, mods?: ModCombination): RulesetBeatmap;
  /**
     * Applies ruleset to a replay.
     * Converts legacy replay frames to ruleset specific frames.
     * @param replay The replay.
     * @param beatmap The beatmap of the replay which is used to get some data.
     * @returns A new instance of the replay with applied ruleset.
     */
  applyToReplay(replay: IReplay, beatmap?: IBeatmap): Replay;
  /**
     * Resets a mod combination from a beatmap.
     * @param beatmap The beatmap.
     * @returns The same beatmap.
     */
  resetMods(beatmap: RulesetBeatmap): RulesetBeatmap;
  /**
     * Creates a new mod combination by converting legacy mod bitwise or string acronyms.
     * @param input Mod bitwise or string acronyms.
     * @returns A new mod combination.
     */
  createModCombination(input?: number | string): ModCombination;
  /**
     * @param beatmap The beatmap for which the calculation will be done.
     * @returns A new difficulty calculator.
     */
  createDifficultyCalculator(beatmap: IBeatmap): DifficultyCalculator;
  /**
     * @param attributes The difficulty attributes.
     * @param score Score information.
     * @returns A new performance calculator.
     */
  createPerformanceCalculator(attributes?: DifficultyAttributes, score?: IScoreInfo): PerformanceCalculator;
}

/**
 * A ruleset.
 */
declare abstract class Ruleset implements IRuleset {
  /**
     * Ruleset ID.
     */
  abstract id: number;
  /**
     * Applies ruleset to a beatmap.
     * @param beatmap The beatmap.
     * @returns A new instance of the beatmap with applied ruleset.
     */
  applyToBeatmap(beatmap: IBeatmap): RulesetBeatmap;
  /**
     * Applies ruleset and mods to a beatmap.
     * @param beatmap The beatmap.
     * @param mods Mod combination.
     * @returns A new beatmap with applied mods.
     */
  applyToBeatmapWithMods(beatmap: IBeatmap, mods?: ModCombination): RulesetBeatmap;
  /**
     * Applies ruleset to a replay.
     * Converts legacy replay frames to ruleset specific frames.
     * @param replay The replay.
     * @param beatmap The beatmap of the replay which is used to get some data.
     * @returns A new instance of the replay with applied ruleset.
     */
  applyToReplay(replay: IReplay, beatmap?: IBeatmap): Replay;
  /**
     * Resets a mod combination from a beatmap.
     * @param beatmap The beatmap.
     * @returns A new beatmap with no mods.
     */
  resetMods(beatmap: IBeatmap): RulesetBeatmap;
  /**
     * Creates a new mod combination by converting legacy mod bitwise or string acronyms.
     * @param input Mod bitwise or string acronyms.
     * @returns A new mod combination.
     */
  abstract createModCombination(input?: number | string): ModCombination;
  /**
     * @returns A new beatmap processor.
     */
  protected abstract _createBeatmapProcessor(): BeatmapProcessor;
  /**
     * @returns A new beatmap converter.
     */
  protected abstract _createBeatmapConverter(): BeatmapConverter;
  /**
     * @returns A new replay converter.
     */
  protected abstract _createReplayConverter(): ReplayConverter;
  /**
     * @param beatmap The beatmap for which the calculation will be done.
     * @returns A new difficulty calculator.
     */
  abstract createDifficultyCalculator(beatmap: IBeatmap): DifficultyCalculator;
  /**
     * @param attributes The difficulty attributes.
     * @param score Score information.
     * @returns A new performance calculator.
     */
  abstract createPerformanceCalculator(attributes?: DifficultyAttributes, score?: IScoreInfo): PerformanceCalculator;
}

/**
 * A score information.
 */
interface IScoreInfo {
  /**
     * A score ID.
     */
  id: number;
  /**
     * A rank of the play.
     */
  rank: keyof typeof ScoreRank;
  /**
     * Total score of the play.
     */
  totalScore: number;
  /**
     * Total accuracy of the play.
     */
  accuracy: number;
  /**
     * The performance of the play.
     */
  totalPerformance: number | null;
  /**
     * Max combo of the play.
     */
  maxCombo: number;
  /**
     * Whether the map was passed or not.
     */
  passed: boolean;
  /**
     * Perfect combo or not?
     */
  perfect: boolean;
  /**
     * Ruleset instance.
     */
  ruleset: IRuleset | null;
  /**
     * Ruleset ID of the play.
     */
  rulesetId: number;
  /**
     * Mods of the play.
     */
  mods: ModCombination | null;
  /**
     * Raw mods of the play.
     */
  rawMods: string | number;
  /**
     * Username of the player who set this play.
     */
  username: string;
  /**
     * User ID of the player who set this play.
     */
  userId: number;
  /**
     * Beatmap of the play.
     */
  beatmap: IBeatmapInfo | null;
  /**
     * Beatmap ID.
     */
  beatmapId: number;
  /**
     * The date when this play was set.
     */
  date: Date;
  /**
     * Hit statistics.
     */
  statistics: HitStatistics;
  /**
     * Beatmap MD5 hash.
     */
  beatmapHashMD5: string;
  /**
     * Number of Gekis in standard, Max 300s in mania.
     */
  countGeki: number;
  /**
     * Number of 300s.
     */
  count300: number;
  /**
     * Number of Katus in standard, 200s in mania.
     */
  countKatu: number;
  /**
     * Number of 100s in standard, 150s in Taiko, 100s in CTB, 100s in mania.
     */
  count100: number;
  /**
     * Number of 50s in standard, small fruit in CTB, 50s in mania.
     */
  count50: number;
  /**
     * Number of misses.
     */
  countMiss: number;
  /**
     * Total hits of a score.
     */
  totalHits: number;
  /**
     * Converts this score information to JSON.
     * @returns Score information convertible to JSON.
     */
  toJSON(): IJsonableScoreInfo;
}

type JsonableScoreInfo = Omit<IScoreInfo, 'beatmap' | 'ruleset' | 'mods' | 'rawMods' | 'statistics' | 'date'>;
/**
 * A score information that can be converted to JSON.
 */
interface IJsonableScoreInfo extends JsonableScoreInfo {
  /**
     * Stringified mods of the play.
     */
  mods: string;
  /**
     * A beatmap information that can be converted to JSON.
     */
  beatmap: IJsonableBeatmapInfo | null;
  /**
     * Hit statistics that can be converted to JSON.
     */
  statistics: IJsonableHitStatistics;
  /**
     * Timestamp when this play was set.
     */
  date: number;
}

/**
 * A score.
 */
interface IScore {
  /**
     * Score information.
     */
  info: IScoreInfo;
  /**
     * Score replay.
     */
  replay: IReplay | null;
}

/**
 * Score extensions.
 */
declare abstract class LegacyScoreExtensions {
  /**
     * Ruleset ID of the play.
     */
  abstract rulesetId: number;
  /**
     * Hit statistics.
     */
  statistics: HitStatistics;
  /**
     * This is only stored for legacy scores.
     * Currently osu!stable uses Geki & Katu in osu!standard.
     * New osu!lazer score format just ignores that data.
     */
  private _legacyCountGeki;
  private _legacyCountKatu;
  /**
     * Number of Gekis in standard, Max 300s in mania.
     */
  get countGeki(): number;
  set countGeki(value: number);
  /**
     * Number of 300s.
     */
  get count300(): number;
  set count300(value: number);
  /**
     * Number of Katus in standard, 200s in mania.
     */
  get countKatu(): number;
  set countKatu(value: number);
  /**
     * Number of 100s in standard, 150s in Taiko, 100s in CTB, 100s in mania.
     */
  get count100(): number;
  set count100(value: number);
  /**
     * Number of 50s in standard, small fruit in CTB, 50s in mania.
     */
  get count50(): number;
  set count50(value: number);
  /**
     * Number of misses.
     */
  get countMiss(): number;
  set countMiss(value: number);
  /**
     * Total hits of a score.
     */
  get totalHits(): number;
}

type JsonableBeatmapInfo = Omit<IBeatmapInfo, 'ruleset' | 'mods' | 'rawMods' | 'deletedAt' | 'updatedAt'>;
/**
 * A beatmap information that can be converted to JSON.
 */
interface IJsonableBeatmapInfo extends JsonableBeatmapInfo {
  /**
     * Stringified mods of the play.
     */
  mods: string;
  /**
     * Timestamp of the beatmap deletion.
     */
  deletedAt: number | null;
  /**
     * Timestamp of the last beatmap update.
     */
  updatedAt: number | null;
}

/**
 * A beatmap information.
 */
interface IBeatmapInfo {
  /**
     * The beatmap ID.
     */
  id: number;
  /**
     * ID of beatmapset of this beatmap.
     */
  beatmapsetId: number;
  /**
     * The beatmap creator ID.
     */
  creatorId: number;
  /**
     * The beatmap creator username.
     */
  creator: string;
  /**
     * Number of the beatmap favourites.
     */
  favourites: number;
  /**
     * Number of passes of the beatmap.
     */
  passcount: number;
  /**
     * Number of playcount of the beatmap.
     */
  playcount: number;
  /**
     * Rank status of the beatmap (Graveyard, Loved, Ranked...)
     */
  status: number;
  /**
     * The beatmap title.
     */
  title: string;
  /**
     * The beatmap artist.
     */
  artist: string;
  /**
     * Difficulty name of the beatmap.
     */
  version: string;
  /**
     * Number of hittable objects of the beatmap.
     */
  hittable: number;
  /**
     * Number of slidable objects of the beatmap.
     */
  slidable: number;
  /**
     * Number of spinnable objects of the beatmap.
     */
  spinnable: number;
  /**
     * Number of holdable objects of the beatmap.
     */
  holdable: number;
  /**
     * Beatmap total hits.
     */
  totalHits: number;
  /**
     * Length of the beatmap in seconds.
     */
  length: number;
  /**
     * Minimal BPM of a beatmap.
     */
  bpmMin: number;
  /**
     * Maximal BPM of a beatmap.
     */
  bpmMax: number;
  /**
     * The most common BPM of a beatmap.
     */
  bpm: number;
  /**
     * Circle size of the beatmap.
     */
  circleSize: number;
  /**
     * Approach rate of the beatmap.
     */
  approachRate: number;
  /**
     * Overall difficulty of the beatmap.
     */
  overallDifficulty: number;
  /**
     * HP drain rate of the beatmap.
     */
  drainRate: number;
  /**
     * Ruleset instance.
     */
  ruleset: IRuleset | null;
  /**
     * The ruleset ID of this beatmap info.
     */
  rulesetId: number;
  /**
     * Mods of this beatmap info.
     */
  mods: ModCombination | null;
  /**
     * Raw mods of this beatmap info.
     */
  rawMods: string | number;
  /**
     * Total star rating of the beatmap.
     */
  starRating: number;
  /**
     * Max combo of the beatmap.
     */
  maxCombo: number;
  /**
     * If this beatmap info is for converted beatmap.
     */
  isConvert: boolean;
  /**
     * The date of the beatmap deletion.
     */
  deletedAt: Date | null;
  /**
     * The date of the last beatmap update.
     */
  updatedAt: Date | null;
  /**
     * Beatmap MD5 hash.
     */
  hashMD5: string;
  /**
     * Converts this beatmap information to a plain object convertible to JSON.
     * @returns Beatmap information convertible to JSON.
     */
  toJSON(): IJsonableBeatmapInfo;
}

/**
 * A score information.
 */
declare class ScoreInfo extends LegacyScoreExtensions implements IScoreInfo {
  /**
     * A score ID.
     */
  id: number;
  /**
     * Total score of the play.
     */
  totalScore: number;
  /**
     * The performance of the play.
     */
  totalPerformance: number | null;
  /**
     * Max combo of the play.
     */
  maxCombo: number;
  /**
     * Whether the map was passed or not.
     * Score rank will always be `F` on `passed = false`.
     */
  passed: boolean;
  /**
     * Perfect combo or not?
     */
  perfect: boolean;
  private _ruleset;
  private _rulesetId;
  private _mods;
  private _rawMods;
  /**
     * Score accuracy.
     */
  get accuracy(): number;
  set accuracy(_: number);
  /**
     * Score rank.
     */
  get rank(): keyof typeof ScoreRank;
  set rank(value: keyof typeof ScoreRank);
  /**
     * Ruleset instance.
     */
  get ruleset(): IRuleset | null;
  set ruleset(value: IRuleset | null);
  /**
     * Ruleset ID of the play.
     */
  get rulesetId(): number;
  set rulesetId(value: number);
  /**
     * Mods of the play.
     * This will always be `null` if {@link ruleset} is not set.
     */
  get mods(): ModCombination | null;
  set mods(value: ModCombination | null);
  /**
     * Raw mods of the play that are neutral to any of the rulesets.
     * This can be either bitwise or stringified mod combination.
     * {@link ScoreInfo} can't work with mod combinations without an actual ruleset instance.
     * TODO: Implement it in a better way???
     */
  get rawMods(): string | number;
  set rawMods(value: string | number);
  /**
     * Username of the player who set this play.
     */
  username: string;
  /**
     * User ID of the player who set this play.
     */
  userId: number;
  /**
     * Beatmap of the play.
     */
  beatmap: IBeatmapInfo | null;
  /**
     * Beatmap ID.
     */
  beatmapId: number;
  /**
     * The date when this play was set.
     */
  date: Date;
  /**
     * Beatmap MD5 hash.
     */
  beatmapHashMD5: string;
  /**
     * Creates a new instance of score information.
     * @param options The score information options.
     */
  constructor(options?: Partial<IScoreInfo>);
  /**
     * Creates a deep copy of the score info.
     * @returns Cloned score info.
     */
  clone(): this;
  /**
     * @param other Other score info.
     * @returns If two scores are equal.
     */
  equals(other: IScoreInfo): boolean;
  /**
     * Converts this score information to a plain object convertible to JSON.
     * @returns Score information convertible to JSON.
     */
  toJSON(): IJsonableScoreInfo;
  /**
     * Converts raw JSON score information to an instance of {@link ScoreInfo}.
     * @param json Raw JSON score information.
     * @returns Adapted instance of {@link ScoreInfo} class.
     */
  static fromJSON(json: IJsonableScoreInfo): ScoreInfo;
}

/**
 * A score.
 */
declare class Score {
  /**
     * Score information.
     */
  info: ScoreInfo;
  /**
     * Score replay.
     */
  replay: Replay | null;
  constructor(info?: ScoreInfo, replay?: Replay | null);
  clone(): this;
  equals(other: IScore): boolean;
}

/**
 * Calculates accuracy of a score.
 * @param scoreInfo Score information.
 * @returns Calculated accuracy.
 */
declare function calculate$1(scoreInfo: IScoreInfo): number;

declare namespace Accuracy {
  export {
    calculate$1 as calculate,
  };
}

/**
 * Calculates rank of a score.
 * @param scoreInfo Score information.
 * @returns Calculated score rank.
 */
declare function calculate(scoreInfo: IScoreInfo): keyof typeof ScoreRank;

declare const Rank_calculate: typeof calculate;
declare namespace Rank {
  export {
    Rank_calculate as calculate,
  };
}

/**
 * A hit object.
 */
interface IHitObject {
  /**
     * The time at which hit object starts.
     */
  startTime: number;
  /**
     * Hit type data of this hit object.
     */
  hitType: HitType;
  /**
     * Hit sound data of this hit object.
     */
  hitSound: HitSound;
  /**
     * Samples of this hit object.
     */
  samples: HitSample[];
  /**
     * Hit windows of this hit object.
     */
  hitWindows: HitWindows;
  /**
     * Creates a new copy of this hit object.
     * @returns a copy of this hit object.
     */
  clone(): IHitObject;
}

/**
 * A type of hit object which may require the last tick to be offset.
 * This is specific to osu!stable conversion, and should not be used elsewhere.
 */
interface IHasLegacyLastTickOffset {
  /**
     * Offset to the last tick.
     */
  legacyLastTickOffset?: number;
}

/**
 * A path point.
 */
declare class PathPoint {
  /**
     * The position at which path point starts.
     */
  position: Vector2;
  /**
     * A type of path point.
     */
  type: PathType | null;
  /**
     * Creates a new instance of path point.
     * @param position The position at which path point starts.
     * @param type A type of path point.
     * @constructor
     */
  constructor(position?: Vector2, type?: PathType | null);
}

declare class SliderPath {
  private _expectedDistance;
  private _controlPoints;
  private _curveType;
  private _calculatedLength;
  private _calculatedPath;
  private _cumulativeLength;
  private _isCached;
  constructor(curveType?: PathType, controlPoints?: PathPoint[], expectedDistance?: number);
  /**
     * Curve type.
     */
  get curveType(): PathType;
  set curveType(value: PathType);
  /**
     * The control points of the path.
     */
  get controlPoints(): PathPoint[];
  set controlPoints(value: PathPoint[]);
  /**
     * The user-set distance of the path.
     * If non-null, distance will match this value,
     * and the path will be shortened/lengthened to match this length.
     */
  get expectedDistance(): number;
  set expectedDistance(value: number);
  /**
     * The distance of the path after lengthening/shortening
     * to account for expected distance.
     */
  get distance(): number;
  set distance(value: number);
  /**
     * The distance of the path prior to lengthening/shortening
     * to account for expected distance.
     */
  get calculatedDistance(): number;
  /**
     * Gets an array of points approximating the path after
     * lengthening/shortening it to account for expected distance.
     */
  get path(): Vector2[];
  /**
     * Gets an array of points approximating the path prior to
     * lengthening/shortening it to account for expected distance.
     */
  get calculatedPath(): Vector2[];
  /**
     * Invalidates path calculations.
     */
  invalidate(): void;
  /**
     * Computes the slider path until a given progress that ranges } from 0 (beginning of the slider)
     * to 1 (end of the slider) and stores the generated path in the given list.
     * @param path The list to be filled with the computed path.
     * @param p0 Start progress. Ranges } from 0 (beginning of the slider) to 1 (end of the slider).
     * @param p1 End progress. Ranges } from 0 (beginning of the slider) to 1 (end of the slider).
     */
  calculatePathToProgress(path: Vector2[], p0: number, p1: number): void;
  /**
     * Computes the progress along the curve relative to how much of the hit object has been completed.
     * @param progress Where 0 is the start time of the hit object and 1 is the end time of the hit object.
     * @param spans Number of spans of the object.
     * @returns Progress of the object on the current span.
     */
  progressAt(progress: number, spans: number): number;
  /**
     * Computes the position on the slider at a given progress
     * that ranges from 0 (beginning of the path) to 1 (end of the path).
     * @param progress Ranges from 0 (beginning of the path) to 1 (end of the path).
     */
  positionAt(progress: number): Vector2;
  /**
     * Computes the position on the curve relative to how much
     * of the hit object has been completed.
     * @param progress Where 0 is the start time of the hit object and 1 is the end time of the hit object.
     * @param spans Number of spans of the object.
     * @returns The position on the curve.
     */
  curvePositionAt(progress: number, spans: number): Vector2;
  clone(): SliderPath;
  private _ensureValid;
  private _calculatePath;
  private _calculateSubPath;
  private _calculateLength;
  private _indexOfDistance;
  private _progressToDistance;
  private _interpolateVertices;
}

/**
 * A hit object that ends at a different time than its start time.
 */
interface IHasDuration {
  /**
     * The time at which the hit object ends.
     */
  endTime: number;
  /**
     * The duration of the hit object.
     */
  duration: number;
}

/**
 * A hit object that has a positional length.
 */
interface IHasDistance extends IHasDuration {
  /**
     * The positional length of the hit object.
     */
  distance: number;
}

/**
 * A hit object with path.
 */
interface IHasPath extends IHasDistance {
  /**
     * The curve.
     */
  path: SliderPath;
}

/**
 * A hit object with node samples.
 */
interface IHasNodeSamples {
  /**
     * The samples to be played when each node of the IHasPath is hit.
     * 0: The first node.
     * 1: The first repeat.
     * 2: The second repeat.
     * ...
     * n-1: The last repeat.
     * n: The last node.
     */
  nodeSamples: HitSample[][];
}

/**
 * A hit object that spans some length.
 */
interface IHasRepeats extends IHasDuration, IHasNodeSamples {
  /**
     * The amount of times the hit object repeats.
     */
  repeats: number;
  /**
     * The number of spans of the hit object.
     */
  spans: number;
  /**
     * The duration of a single span.
     */
  spanDuration: number;
}

/**
 * A HitObject that has a curve.
 */
interface IHasPathWithRepeats extends IHasPath, IHasRepeats {
}

interface ISlidableObject extends IHasPathWithRepeats, IHitObject, IHasLegacyLastTickOffset {
  /**
     * Spacing between ticks of a slidable object.
     */
  tickDistance?: number;
  /**
     * The length (in milliseconds) between ticks of this slidable object.
     */
  tickInterval?: number;
  /**
     * An extra multiplier that affects the number of ticks
     * generated by this slidable object.
     * An increase in this value increases tick distance,
     * which reduces the number of ticks generated.
     */
  tickRate?: number;
  /**
     * Velocity of a slidable object.
     */
  velocity: number;
}

/**
 * A tick generator for end time objects.
 */
declare abstract class EventGenerator {
  /**
     * A very lenient maximum distance of a slider for ticks to be generated.
     * This exists for edge cases such as /b/1573664
     * where the beatmap has been edited by the user,
     * and should never be reached in normal usage.
     */
  static SLIDER_MAX_DISTANCE: number;
  /**
     * Generates ticks for an end time object.
     * @param slider A slidable object.
     * @generator
     */
  static generate(slider: ISlidableObject): Generator<ISliderEventDescriptor>;
}
/**
 * A nested event.
 */
interface ISliderEventDescriptor {
  /**
     * The type of event.
     */
  eventType: SliderEventType;
  /**
     * The zero-based index of the span. In the case of repeat sliders,
     * this will increase after each slider repeat.
     */
  spanIndex: number;
  /**
     * The time at which the contained span index begins.
     */
  spanStartTime: number;
  /**
     * The time at which this nested event starts.
     */
  startTime: number;
  /**
     * The progress along the slider's path at which this event occurs.
     */
  progress: number;
}

/**
 * An object of a parsed beatmap.
 */
declare abstract class HitObject implements IHitObject {
  /**
     * The status of kiai mode at the current hit object.
     */
  kiai: boolean;
  /**
     * Nested objects of the hit object.
     */
  nestedHitObjects: HitObject[];
  /**
     * The time at which the hit object starts.
     */
  startTime: number;
  /**
     * Parsed hit type data of a hit object.
     */
  hitType: HitType;
  /**
     * Parsed hit sound data of a hit object.
     */
  hitSound: HitSound;
  /**
     * The samples to be played when this hit object is hit.
     */
  samples: HitSample[];
  /**
     * The position at which the hit object starts.
     */
  startPosition: Vector2;
  /**
     * Hit windows of this hit object.
     */
  hitWindows: HitWindows;
  /**
     * The starting X-position of this hit object.
     */
  get startX(): number;
  set startX(value: number);
  /**
     * The starting Y-position of this hit object.
     */
  get startY(): number;
  set startY(value: number);
  /**
     * Generates a list of nested hit objects.
     */
  createNestedHitObjects(): void;
  /**
     * Applies default values to the hit object.
     * @param controlPoints Beatmap control points.
     */
  applyDefaultsToSelf(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  /**
     * Applies default values to the nested hit objects.
     * @param controlPoints Beatmap control points.
     * @param difficulty Beatmap Difficulty.
     */
  applyDefaultsToNested(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  /**
     * Applies default values to the hit object and it's nested hit objects.
     * @param controlPoints Beatmap control points.
     * @param difficulty Beatmap Difficulty.
     */
  applyDefaults(controlPoints: ControlPointInfo, difficulty: BeatmapDifficultySection): void;
  /**
     * Create a new copy of a hit object.
     * @returns A clone of this hit object.
     */
  clone(): this;
}

interface IHoldableObject extends IHitObject, IHasDuration, IHasNodeSamples {
}

interface ISpinnableObject extends IHitObject, IHasDuration {
}

/**
 * Helper methods to approximate a path by interpolating a sequence of control points.
 */
declare class PathApproximator {
  static readonly BEZIER_TOLERANCE: number;
  static readonly CIRCULAR_ARC_TOLERANCE: number;
  /**
     * The amount of pieces to calculate for each control point quadruplet.
     */
  static readonly CATMULL_DETAIL = 50;
  /**
     * Creates a piecewise-linear approximation of a bezier curve, by adaptively repeatedly subdividing
     * the control points until their approximation error vanishes below a given threshold.
     * @param controlPoints The control points of the path.
     * @returns A list of vectors representing the piecewise-linear approximation.
     */
  static approximateBezier(controlPoints: Vector2[]): Vector2[];
  /**
     * Creates a piecewise-linear approximation of a clamped uniform B-spline with polynomial order p,
     * by dividing it into a series of bezier control points at its knots, then adaptively repeatedly
     * subdividing those until their approximation error vanishes below a given threshold.
     * Retains previous bezier approximation functionality when p is 0 or too large to create knots.
     * Algorithm unsuitable for large values of p with many knots.
     * @param controlPoints The control points.
     * @param p The polynomial order.
     * @returns A list of vectors representing the piecewise-linear approximation.
     */
  static approximateBSpline(controlPoints: Vector2[], p?: number): Vector2[];
  /**
     * Creates a piecewise-linear approximation of a Catmull-Rom spline.
     * @param controlPoints The control points of the path.
     * @returns A list of vectors representing the piecewise-linear approximation.
     */
  static approximateCatmull(controlPoints: Vector2[]): Vector2[];
  /**
     * Creates a piecewise-linear approximation of a circular arc curve.
     * @param controlPoints The control points of the path.
     * @returns A list of vectors representing the piecewise-linear approximation.
     */
  static approximateCircularArc(controlPoints: Vector2[]): Vector2[];
  /**
     * Computes various properties that can be used to approximate the circular arc.
     * @param controlPoints Three distinct points on the arc.
     * @returns The properties for approximation of the circular arc.
     */
  static _circularArcProperties(controlPoints: Vector2[]): CircularArcProperties;
  /**
     * Creates a piecewise-linear approximation of a linear curve.
     * Basically, returns the input.
     * @param controlPoints The control points of the path.
     * @returns A list of vectors representing the piecewise-linear approximation.
     */
  static approximateLinear(controlPoints: Vector2[]): Vector2[];
  /**
     * Creates a piecewise-linear approximation of a lagrange polynomial.
     * @param controlPoints The control points of the path.
     * @returns A list of vectors representing the piecewise-linear approximation.
     */
  static approximateLagrangePolynomial(controlPoints: Vector2[]): Vector2[];
  /**
     * Make sure the 2nd order derivative (approximated using finite elements) is within tolerable bounds.
     * NOTE: The 2nd order derivative of a 2d curve represents its curvature, so intuitively this function
     *       checks (as the name suggests) whether our approximation is _locally_ "flat". More curvy parts
     *       need to have a denser approximation to be more "flat".
     * @param controlPoints The control points to check for flatness.
     * @returns Whether the control points are flat enough.
     */
  private static _bezierIsFlatEnough;
  /**
     * Subdivides n control points representing a bezier curve into 2 sets of n control points, each
     * describing a bezier curve equivalent to a half of the original curve. Effectively this splits
     * the original curve into 2 curves which result in the original curve when pieced back together.
     * @param controlPoints The control points to split.
     * @param l Output: The control points corresponding to the left half of the curve.
     * @param r Output: The control points corresponding to the right half of the curve.
     * @param subdivisionBuffer The first buffer containing the current subdivision state.
     * @param count The number of control points in the original list.
     */
  private static _bezierSubdivide;
  /**
     * This uses De Casteljau's algorithm to obtain an optimal
     * piecewise-linear approximation of the bezier curve with the same amount of points as there are control points.
     * @param controlPoints The control points describing the bezier curve to be approximated.
     * @param output The points representing the resulting piecewise-linear approximation.
     * @param count The number of control points in the original list.
     * @param subdivisionBuffer1 The first buffer containing the current subdivision state.
     * @param subdivisionBuffer2 The second buffer containing the current subdivision state.
     */
  private static _bezierApproximate;
  /**
     * Finds a point on the spline at the position of a parameter.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @param vec3 The third vector.
     * @param vec4 The fourth vector.
     * @param t The parameter at which to find the point on the spline, in the range [0, 1].
     * @returns The point on the spline at t.
     */
  private static _catmullFindPoint;
}
/**
 * The properties for approximation of the circular arc.
 */
declare class CircularArcProperties {
  /**
     * Whether the properties are valid.
     */
  readonly isValid: boolean;
  /**
     * Starting angle of the circle.
     */
  readonly thetaStart: number;
  /**
     * The angle of the drawn circle.
     */
  readonly thetaRange: number;
  /**
     * The direction in which the circle will be drawn.
     */
  readonly direction: number;
  /**
     * The radius of a circle.
     */
  readonly radius: number;
  /**
     * The centre position of a circle.
     */
  readonly centre: Vector2;
  constructor(thetaStart?: number, thetaRange?: number, direction?: number, radius?: number, centre?: Vector2);
  get thetaEnd(): number;
}

declare class SampleBank {
  /**
     * The filepath of this sample bank.
     */
  filename: string;
  /**
     * The volume of the bank.
     */
  volume: number;
  /**
     * The normal sample set of the bank.
     */
  normalSet: SampleSet;
  /**
     * The addition sample set of the bank.
     */
  additionSet: SampleSet;
  /**
     * Custom index of the sample bank.
     */
  customIndex: number;
  /**
     * Creates a copy of this sample bank.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied sample bank.
     */
  clone(): SampleBank;
}

/**
 * A type of hit object which lies in one of a number of predetermined columns.
 */
interface IHasColumn {
  /**
     * The column which the hit object lies in.
     */
  column: number;
}

/**
 * A hit object that is part of a combo.
 */
interface IHasCombo {
  /**
     * Whether the hit object starts a new combo.
     */
  isNewCombo: boolean;
  /**
     * When starting a new combo, the offset of the new combo relative to the current one.
     */
  comboOffset: number;
}

/**
 * A hit object that is part of a combo and has extended information
 * about its position relative to other combo objects.
 */
interface IHasComboInformation extends IHasCombo {
  /**
     * The index of this hit object in the current combo.
     */
  currentComboIndex: number;
  /**
     * The index of this combo in relation to the beatmap.
     */
  comboIndex: number;
  /**
     * The index of this combo in relation to the beatmap, with applied combo offset.
     * This should be used instead of original combo index
     * only when retrieving combo colors from the beatmap's skin.
     */
  comboIndexWithOffsets: number;
  /**
     * Whether this is the last object in the current combo.
     */
  lastInCombo: boolean;
}

/**
 * A hit object with X-position.
 */
interface IHasX {
  /**
     * Starting X-position of the hit object.
     */
  startX: number;
  /**
     * Ending X-position of the hit object.
     */
  endX: number;
}

/**
 * A hit object with Y-position.
 */
interface IHasY {
  /**
     * Starting Y-position of the hit object.
     */
  startY: number;
  /**
     * Ending Y-position of the hit object.
     */
  endX: number;
}

/**
 * A hit object that has a position.
 */
interface IHasPosition extends IHasX, IHasY {
  /**
     * The position at which hit object starts.
     */
  startPosition: Vector2;
  /**
     * The position at which hit object ends.
     */
  endPosition: Vector2;
}

/**
 * A beatmap.
 */
interface IBeatmap {
  /**
     * The optional link to the base beatmap.
     * Base beatmap prefered for beatmap convertation.
     */
  base?: IBeatmap;
  /**
     * Beatmap general info.
     */
  general: BeatmapGeneralSection;
  /**
     * Beatmap editor settings.
     */
  editor: BeatmapEditorSection;
  /**
     * Beatmap difficulty.
     */
  difficulty: BeatmapDifficultySection;
  /**
     * Beatmap metadata.
     */
  metadata: BeatmapMetadataSection;
  /**
     * Beatmap skin configuration.
     */
  colors: BeatmapColorSection;
  /**
     * Beatmap events & storyboard.
     */
  events: BeatmapEventSection;
  /**
     * Beatmap control points.
     */
  controlPoints: ControlPointInfo;
  /**
     * Beatmap hit objects.
     */
  hitObjects: IHitObject[];
  /**
     * Beatmap game mode.
     */
  mode: number;
  /**
     * Beatmap original game mode.
     */
  originalMode: number;
  /**
     * Beatmap file version.
     */
  fileFormat: number;
  /**
     * Beatmap length in milliseconds.
     */
  length: number;
  /**
     * Minimal BPM of a beatmap.
     */
  bpmMin: number;
  /**
     * Maximal BPM of a beatmap.
     */
  bpmMax: number;
  /**
     * The most common BPM of a beatmap.
     */
  bpm: number;
  /**
     * The total break time of a beatmap.
     */
  totalBreakTime: number;
  /**
     * Create a new copy of beatmap.
     * @returns A clone of beatmap.
     */
  clone(): IBeatmap;
}

/**
 * A parsed beatmap.
 */
declare class Beatmap implements IBeatmap {
  /**
     * The optional link to the base beatmap.
     * Base beatmap is preferrable for beatmap converters.
     */
  base?: IBeatmap;
  /**
     * Beatmap general info.
     */
  general: BeatmapGeneralSection;
  /**
     * Beatmap editor settings.
     */
  editor: BeatmapEditorSection;
  /**
     * Beatmap difficulty.
     */
  difficulty: BeatmapDifficultySection;
  /**
     * Beatmap metadata.
     */
  metadata: BeatmapMetadataSection;
  /**
     * Beatmap skin configuration.
     */
  colors: BeatmapColorSection;
  /**
     * Beatmap events & Storyboard.
     */
  events: BeatmapEventSection;
  /**
     * Beatmap control points.
     */
  controlPoints: ControlPointInfo;
  /**
     * Beatmap hit objects.
     */
  hitObjects: HitObject[];
  /**
     * Beatmap file version.
     */
  fileFormat: number;
  /**
     * The date when the beatmap file was updated last time.
     */
  fileUpdateDate: Date;
  /**
     * Original gamemode of a beatmap before any conversions.
     */
  originalMode: number;
  /**
     * Beatmap gamemode.
     */
  get mode(): number;
  /**
     * Playable beatmap length in milliseconds.
     */
  get length(): number;
  /**
     * Total beatmap length in milliseconds.
     */
  get totalLength(): number;
  /**
     * Minimal BPM of a beatmap.
     */
  get bpmMin(): number;
  /**
     * Maximal BPM of a beatmap.
     */
  get bpmMax(): number;
  /**
     * The most common BPM of a beatmap.
     */
  get bpm(): number;
  /**
     * The total break time of a beatmap.
     */
  get totalBreakTime(): number;
  /**
     * The ammount of hittable objects.
     */
  get hittable(): number;
  /**
     * The ammount of slidable objects.
     */
  get slidable(): number;
  /**
     * The ammount of spinnable objects.
     */
  get spinnable(): number;
  /**
     * The ammount of holdable objects.
     */
  get holdable(): number;
  /**
     * Creates a copy of this beatmap.
     * Non-primitive properties will be copied via their own clone() method.
     * @returns A copied beatmap.
     */
  clone(): this;
}

/**
 * A beatmap information.
 */
declare class BeatmapInfo implements IBeatmapInfo {
  /**
     * The beatmap ID.
     */
  id: number;
  /**
     * ID of beatmapset of this beatmap.
     */
  beatmapsetId: number;
  /**
     * The beatmap creator ID.
     */
  creatorId: number;
  /**
     * The beatmap creator username.
     */
  creator: string;
  /**
     * Number of the beatmap favourites.
     */
  favourites: number;
  /**
     * Number of passes of the beatmap.
     */
  passcount: number;
  /**
     * Number of playcount of the beatmap.
     */
  playcount: number;
  /**
     * Rank status of the beatmap (Graveyard, Loved, Ranked...)
     */
  status: number;
  /**
     * The beatmap title.
     */
  title: string;
  /**
     * The beatmap artist.
     */
  artist: string;
  /**
     * Difficulty name of the beatmap.
     */
  version: string;
  /**
     * Number of hittable objects of the beatmap.
     */
  hittable: number;
  /**
     * Number of slidable objects of the beatmap.
     */
  slidable: number;
  /**
     * Number of spinnable objects of the beatmap.
     */
  spinnable: number;
  /**
     * Number of holdable objects of the beatmap.
     */
  holdable: number;
  /**
     * Length of the beatmap in seconds.
     */
  length: number;
  /**
     * Minimal BPM of a beatmap.
     */
  bpmMin: number;
  /**
     * Maximal BPM of a beatmap.
     */
  bpmMax: number;
  /**
     * The most common BPM of a beatmap.
     */
  bpm: number;
  /**
     * Circle size of the beatmap.
     */
  circleSize: number;
  /**
     * Approach rate of the beatmap.
     */
  approachRate: number;
  /**
     * Overall difficulty of the beatmap.
     */
  overallDifficulty: number;
  /**
     * HP drain rate of the beatmap.
     */
  drainRate: number;
  /**
     * Ruleset instance.
     */
  private _ruleset;
  get ruleset(): IRuleset | null;
  set ruleset(value: IRuleset | null);
  /**
     * Ruleset ID of this beatmap info.
     */
  private _rulesetId;
  get rulesetId(): number;
  set rulesetId(value: number);
  /**
     * Mods of this beatmap info.
     */
  private _mods;
  get mods(): ModCombination | null;
  set mods(value: ModCombination | null);
  /**
     * Raw mods of this beatmap info.
     */
  private _rawMods;
  get rawMods(): string | number;
  set rawMods(value: string | number);
  /**
     * Total star rating of the beatmap.
     */
  starRating: number;
  /**
     * Max combo of the beatmap.
     */
  maxCombo: number;
  /**
     * If this beatmap info is for converted beatmap.
     */
  isConvert: boolean;
  /**
     * The date of the beatmap deletion.
     */
  deletedAt: Date | null;
  /**
     * The date of the last beatmap update.
     */
  updatedAt: Date | null;
  /**
     * Beatmap MD5 hash.
     */
  hashMD5: string;
  /**
     * Creates a new instance of a beatmap information.
     * @param options The beatmap information options.
     */
  constructor(options?: Partial<IBeatmapInfo>);
  /**
     * Beatmap total hits.
     */
  get totalHits(): number;
  /**
     * Creates a new deep copy of a beatmap info.
     * @returns Cloned beatmap info.
     */
  clone(): this;
  /**
     * @param other Other beatmap info.
     * @returns If two beatmaps are equal.
     */
  equals(other: IBeatmapInfo): boolean;
  /**
     * Converts this beatmap information to a plain object convertible to JSON.
     * @returns Beatmap information convertible to JSON.
     */
  toJSON(): IJsonableBeatmapInfo;
  /**
     * Converts raw JSON beatmap information to an instance of {@link BeatmapInfo}.
     * @param json Raw JSON beatmap information.
     * @returns Adapted instance of {@link BeatmapInfo} class.
     */
  static fromJSON(json: IJsonableBeatmapInfo): BeatmapInfo;
}

/**
 * A beatmap processor.
 */
declare abstract class BeatmapProcessor {
  /**
     * Performs beatmap pre-processing. Mutates original beatmap.
     * @param beatmap A beatmap.
     * @returns The link to the same beatmap.
     */
  preProcess(beatmap: IBeatmap): IBeatmap;
  /**
     * Performs beatmap post processing. Mutates original beatmap.
     * @param beatmap A beatmap.
     * @returns The link to the same beatmap.
     */
  postProcess(beatmap: IBeatmap): IBeatmap;
}

/**
 * All types of effects.
 */
declare enum EffectType {
  None = 0,
  Kiai = 1,
  OmitFirstBarLine = 8
}

/**
 * Used to calculate timed difficulty attributes,
 * where only a subset of hitobjects should be visible at any point in time.
 */
declare class ProgressiveCalculationBeatmap implements IBeatmap {
  private readonly _baseBeatmap;
  constructor(baseBeatmap: IBeatmap);
  /**
     * Beatmap hit objects.
     */
  hitObjects: IHitObject[];
  /**
     * Beatmap general info.
     */
  get general(): BeatmapGeneralSection;
  set general(value: BeatmapGeneralSection);
  /**
     * Beatmap editor settings.
     */
  get editor(): BeatmapEditorSection;
  set editor(value: BeatmapEditorSection);
  /**
     * Beatmap difficulty.
     */
  get difficulty(): BeatmapDifficultySection;
  set difficulty(value: BeatmapDifficultySection);
  /**
     * Beatmap metadata.
     */
  get metadata(): BeatmapMetadataSection;
  set metadata(value: BeatmapMetadataSection);
  /**
     * Beatmap skin configuration.
     */
  get colors(): BeatmapColorSection;
  set colors(value: BeatmapColorSection);
  /**
     * Beatmap events & Storyboard.
     */
  get events(): BeatmapEventSection;
  set events(value: BeatmapEventSection);
  /**
     * Beatmap control points.
     */
  get controlPoints(): ControlPointInfo;
  set controlPoints(value: ControlPointInfo);
  /**
     * Beatmap gamemode.
     */
  get mode(): number;
  /**
     * Beatmap original gamemode.
     */
  get originalMode(): number;
  /**
     * Beatmap file version.
     */
  get fileFormat(): number;
  /**
     * Beatmap length in milliseconds.
     */
  get length(): number;
  /**
     * Minimal BPM of a beatmap.
     */
  get bpmMin(): number;
  /**
     * Maximal BPM of a beatmap.
     */
  get bpmMax(): number;
  /**
     * The most common BPM of a beatmap.
     */
  get bpm(): number;
  /**
     * The total break time of a beatmap.
     */
  get totalBreakTime(): number;
  /**
     * Create a new copy of this beatmap.
     * @returns A clone of this beatmap.
     */
  clone(): ProgressiveCalculationBeatmap;
}

declare enum CountryCode {
  Unknown = 0,
  BD = 1,
  BE = 2,
  BF = 3,
  BG = 4,
  BA = 5,
  BB = 6,
  WF = 7,
  BL = 8,
  BM = 9,
  BN = 10,
  BO = 11,
  BH = 12,
  BI = 13,
  BJ = 14,
  BT = 15,
  JM = 16,
  BV = 17,
  BW = 18,
  WS = 19,
  BQ = 20,
  BR = 21,
  BS = 22,
  JE = 23,
  BY = 24,
  BZ = 25,
  RU = 26,
  RW = 27,
  RS = 28,
  TL = 29,
  RE = 30,
  TM = 31,
  TJ = 32,
  RO = 33,
  TK = 34,
  GW = 35,
  GU = 36,
  GT = 37,
  GS = 38,
  GR = 39,
  GQ = 40,
  GP = 41,
  JP = 42,
  GY = 43,
  GG = 44,
  GF = 45,
  GE = 46,
  GD = 47,
  GB = 48,
  GA = 49,
  SV = 50,
  GN = 51,
  GM = 52,
  GL = 53,
  GI = 54,
  GH = 55,
  OM = 56,
  TN = 57,
  JO = 58,
  HR = 59,
  HT = 60,
  HU = 61,
  HK = 62,
  HN = 63,
  HM = 64,
  VE = 65,
  PR = 66,
  PS = 67,
  PW = 68,
  PT = 69,
  SJ = 70,
  PY = 71,
  IQ = 72,
  PA = 73,
  PF = 74,
  PG = 75,
  PE = 76,
  PK = 77,
  PH = 78,
  PN = 79,
  PL = 80,
  PM = 81,
  ZM = 82,
  EH = 83,
  EE = 84,
  EG = 85,
  ZA = 86,
  EC = 87,
  IT = 88,
  VN = 89,
  SB = 90,
  ET = 91,
  SO = 92,
  ZW = 93,
  SA = 94,
  ES = 95,
  ER = 96,
  ME = 97,
  MD = 98,
  MG = 99,
  MF = 100,
  MA = 101,
  MC = 102,
  UZ = 103,
  MM = 104,
  ML = 105,
  MO = 106,
  MN = 107,
  MH = 108,
  MK = 109,
  MU = 110,
  MT = 111,
  MW = 112,
  MV = 113,
  MQ = 114,
  MP = 115,
  MS = 116,
  MR = 117,
  IM = 118,
  UG = 119,
  TZ = 120,
  MY = 121,
  MX = 122,
  IL = 123,
  FR = 124,
  IO = 125,
  SH = 126,
  FI = 127,
  FJ = 128,
  FK = 129,
  FM = 130,
  FO = 131,
  NI = 132,
  NL = 133,
  NO = 134,
  NA = 135,
  VU = 136,
  NC = 137,
  NE = 138,
  NF = 139,
  NG = 140,
  NZ = 141,
  NP = 142,
  NR = 143,
  NU = 144,
  CK = 145,
  XK = 146,
  CI = 147,
  CH = 148,
  CO = 149,
  CN = 150,
  CM = 151,
  CL = 152,
  CC = 153,
  CA = 154,
  CG = 155,
  CF = 156,
  CD = 157,
  CZ = 158,
  CY = 159,
  CX = 160,
  CR = 161,
  CW = 162,
  CV = 163,
  CU = 164,
  SZ = 165,
  SY = 166,
  SX = 167,
  KG = 168,
  KE = 169,
  SS = 170,
  SR = 171,
  KI = 172,
  KH = 173,
  KN = 174,
  KM = 175,
  ST = 176,
  SK = 177,
  KR = 178,
  SI = 179,
  KP = 180,
  KW = 181,
  SN = 182,
  SM = 183,
  SL = 184,
  SC = 185,
  KZ = 186,
  KY = 187,
  SG = 188,
  SE = 189,
  SD = 190,
  DO = 191,
  DM = 192,
  DJ = 193,
  DK = 194,
  VG = 195,
  DE = 196,
  YE = 197,
  DZ = 198,
  US = 199,
  UY = 200,
  YT = 201,
  UM = 202,
  LB = 203,
  LC = 204,
  LA = 205,
  TV = 206,
  TW = 207,
  TT = 208,
  TR = 209,
  LK = 210,
  LI = 211,
  LV = 212,
  TO = 213,
  LT = 214,
  LU = 215,
  LR = 216,
  LS = 217,
  TH = 218,
  TF = 219,
  TG = 220,
  TD = 221,
  TC = 222,
  LY = 223,
  VA = 224,
  VC = 225,
  AE = 226,
  AD = 227,
  AG = 228,
  AF = 229,
  AI = 230,
  VI = 231,
  IS = 232,
  IR = 233,
  AM = 234,
  AL = 235,
  AO = 236,
  AQ = 237,
  AS = 238,
  AR = 239,
  AU = 240,
  AT = 241,
  AW = 242,
  IN = 243,
  AX = 244,
  AZ = 245,
  IE = 246,
  ID = 247,
  UA = 248,
  QA = 249,
  MZ = 250
}

type IJsonableGrades = Partial<Record<keyof typeof ScoreRank, number>>;
/**
 * A special case of a map structure for storing the number of user's grades.
 */
declare class Grades extends Map<keyof typeof ScoreRank, number> {
  /**
     * Gets the number of grades by their type.
     * If grade is not present sets it to default value and returns it.
     * @param key Score rank type.
     * @returns The number of grades of this type.
     */
  get(key: keyof typeof ScoreRank): number;
  /**
     * If user has zero grades in total.
     */
  get hasZeroGrades(): boolean;
  /**
     * Converts this map to a readable JSON format.
     */
  toJSON(): IJsonableGrades;
  static fromJSON(json: IJsonableGrades): Grades;
}

/**
 * A highest rank information that can be converted to JSON.
 */
interface IJsonableHighestRank {
  /**
     * Highest rank of the user.
     */
  rank: number;
  /**
     * Timestamp of the date when this rank was achieved.
     */
  updatedAt: number;
}
/**
 * A class that represents highest rank of the user.
 */
declare class HighestRank {
  /**
     * Highest rank of the user.
     */
  rank: number;
  /**
     * The date when highest rank was achieved.
     */
  updatedAt: Date;
  constructor(options?: Partial<HighestRank>);
  /**
     * Creates a deep copy of the highest rank instance.
     * @returns Cloned highest rank instance.
     */
  clone(): HighestRank;
  /**
     * Converts this map to a readable JSON format.
     */
  toJSON(): IJsonableHighestRank;
  static fromJSON(json: IJsonableHighestRank): HighestRank;
}

/**
 * A level information of a user.
 */
declare class LevelInfo {
  /**
     * Current level of a user as integer.
     */
  current: number;
  /**
     * Progress to the next level as integer in range of 0-100.
     */
  progress: number;
  constructor(options?: Partial<LevelInfo>);
  /**
     * Creates a deep copy of the level info.
     * @returns Cloned level info.
     */
  clone(): LevelInfo;
  /**
     * @returns Stringified level information.
     */
  toString(): string;
}

/**
 * A class that represents rank history of a user.
 */
declare class RankHistory {
  static DEFAULT_MODE: string;
  /**
     * A mode to which this data belongs.
     */
  mode: string;
  /**
     * List of previous ranks at different points of history.
     */
  data: number[];
  constructor(options?: Partial<RankHistory>);
  /**
     * If this rank history has valid mode and more than 1 entry to build a graph.
     */
  get hasEnoughData(): boolean;
  /**
     * Creates a deep copy of the rank history.
     * @returns Cloned rank history.
     */
  clone(): RankHistory;
}

/**
 * A user information.
 */
interface IUserInfo {
  /**
     * User ID.
     */
  id: number;
  /**
     * User's name.
     */
  username: string;
  /**
     * Previous nicknames of the user.
     */
  previousUsernames: string[];
  /**
     * User country code.
     */
  countryCode: keyof typeof CountryCode;
  /**
     * Playmode of the user.
     */
  playmode: number;
  /**
     * User performance points.
     */
  totalPerformance: number;
  /**
     * Rank in the global top.
     */
  globalRank: number | null;
  /**
     * Rank in the country top.
     */
  countryRank: number | null;
  /**
     * Highest rank of the user.
     */
  highestRank: HighestRank | null;
  /**
     * Information about a user's level.
     */
  level: LevelInfo;
  /**
     * Ranked score of a user.
     */
  rankedScore: number;
  /**
     * Total score of a user.
     */
  totalScore: number;
  /**
     * Total accuracy of a user.
     */
  accuracy: number;
  /**
     * Total playcount of a user.
     */
  playcount: number;
  /**
     * Total playtime of a user.
     */
  playtime: number;
  /**
     * Total hits of a user.
     */
  totalHits: number;
  /**
     * Max combo of a user.
     */
  maxCombo: number;
  /**
     * How many times this user's replays have been watched.
     */
  replaysWatched: number;
  /**
     * How many followers does user have.
     */
  followersCount: number;
  /**
     * Grades count of a user.
     */
  grades: Grades;
  /**
     * Rank history of a user.
     */
  rankHistory: RankHistory | null;
  /**
     * Whether the user is active or not.
     */
  isActive: boolean;
  /**
     * Whether the user is bot or not.
     */
  isBot: boolean;
  /**
     * Whether the user is deleted or not.
     */
  isDeleted: boolean;
  /**
     * Whether the user is online or not.
     */
  isOnline: boolean;
  /**
     * Whether the user is supporter or not.
     */
  isSupporter: boolean;
  /**
     * Last visit date of the user.
     */
  lastVisitAt: Date | null;
  /**
     * Join date of the user.
     */
  joinedAt: Date;
}

type JsonableUserInfo = Omit<IUserInfo, 'grades' | 'lastVisitAt' | 'joinedAt' | 'highestRank'>;
interface IJsonableUserInfo extends JsonableUserInfo {
  /**
     * Grades count of a user.
     */
  grades: IJsonableGrades;
  /**
     * Highest rank of the user.
     */
  highestRank: IJsonableHighestRank | null;
  /**
     * Timestamp of last visit of the user.
     */
  lastVisitAt: number | null;
  /**
     * Timestamp of join date of the user.
     */
  joinedAt: number;
}

/**
 * A user information.
 */
declare class UserInfo implements IUserInfo {
  /**
     * User ID.
     */
  id: number;
  /**
     * User's name.
     */
  username: string;
  /**
     * Previous nicknames of the user.
     */
  previousUsernames: string[];
  /**
     * User country code.
     */
  countryCode: keyof typeof CountryCode;
  /**
     * Playmode of the user.
     */
  playmode: number;
  /**
     * User performance points.
     */
  totalPerformance: number;
  /**
     * Rank in the global top.
     */
  globalRank: number | null;
  /**
     * Rank in the country top.
     */
  countryRank: number | null;
  /**
     * Highest rank of the user.
     */
  highestRank: HighestRank | null;
  /**
     * Information about a user's level.
     */
  level: LevelInfo;
  /**
     * Ranked score of a user.
     */
  rankedScore: number;
  /**
     * Total score of a user.
     */
  totalScore: number;
  /**
     * Total accuracy of a user.
     */
  accuracy: number;
  /**
     * Total playcount of a user.
     */
  playcount: number;
  /**
     * Total playtime of a user.
     */
  playtime: number;
  /**
     * Total hits of a user.
     */
  totalHits: number;
  /**
     * Max combo of a user.
     */
  maxCombo: number;
  /**
     * How many times this user's replays have been watched.
     */
  replaysWatched: number;
  /**
     * How many followers does user have.
     */
  followersCount: number;
  /**
     * Grades count of a user.
     */
  grades: Grades;
  /**
     * Rank history of a user.
     */
  rankHistory: RankHistory | null;
  /**
     * Whether the user is active or not.
     */
  isActive: boolean;
  /**
     * Whether the user is bot or not.
     */
  isBot: boolean;
  /**
     * Whether the user is deleted or not.
     */
  isDeleted: boolean;
  /**
     * Whether the user is online or not.
     */
  isOnline: boolean;
  /**
     * Whether the user is supporter or not.
     */
  isSupporter: boolean;
  /**
     * Last visit date of the user.
     */
  lastVisitAt: Date | null;
  /**
     * Join date of the user.
     */
  joinedAt: Date;
  /**
     * Creates a new instance of a user information.
     * @param options The user information options.
     */
  constructor(options?: Partial<IUserInfo>);
  /**
     * Creates a new deep copy of a user info.
     * @returns Cloned user info.
     */
  clone(): this;
  /**
     * @param other Other user info.
     * @returns If two users are equal.
     */
  equals(other: IUserInfo): boolean;
  /**
     * Converts this user information to a plain object convertible to JSON.
     * @returns User information convertible to JSON.
     */
  toJSON(): IJsonableUserInfo;
  /**
     * Converts raw JSON user information to an instance of {@link UserInfo}.
     * @param json Raw JSON user information.
     * @returns Adapted instance of {@link UserInfo} class.
     */
  static fromJSON(json: IJsonableUserInfo): UserInfo;
}

type BinarySearchPredicate<T> = (value: T, index: number, arr: T[]) => boolean;
/**
 * Searches an entire one-dimensional sorted array for a specific value.
 * @param arr The sorted one-dimensional array to search.
 * @param x The value to search for.
 * @returns Found value.
 */
declare function findNumber(arr: number[], x: number): number;
/**
 * Searches a control point at the specified time.
 * @param arr The list of control points.
 * @param time The time to search for.
 * @returns Found control point.
 */
declare function findControlPointIndex(arr: ControlPoint[], time: number): number;
/**
 * Searches a control point at the specified time.
 * @param arr The list of control points.
 * @param time The time to search for.
 * @returns Found control point.
 */
declare function findControlPoint(arr: ControlPoint[], time: number): ControlPoint | null;
/**
 * Searches for a value by predicate function.
 * @param arr The list of any values.
 * @param predicate Predicate function.
 * @returns Found index or -1.
 */
declare function findIndex<T>(arr: T[], predicate: BinarySearchPredicate<T>): number;

type BinarySearch_BinarySearchPredicate<_0> = BinarySearchPredicate<_0>;
declare const BinarySearch_findNumber: typeof findNumber;
declare const BinarySearch_findControlPointIndex: typeof findControlPointIndex;
declare const BinarySearch_findControlPoint: typeof findControlPoint;
declare const BinarySearch_findIndex: typeof findIndex;
declare namespace BinarySearch {
  export {
    BinarySearch_BinarySearchPredicate as BinarySearchPredicate,
    BinarySearch_findNumber as findNumber,
    BinarySearch_findControlPointIndex as findControlPointIndex,
    BinarySearch_findControlPoint as findControlPoint,
    BinarySearch_findIndex as findIndex,
  };
}

/**
 * Calculates the Barycentric weights
 * for a Lagrange polynomial for a given set of coordinates.
 * Can be used as a helper function
 * to compute a Lagrange polynomial repeatedly.
 * @param points An array of coordinates. No two x should be the same.
 */
declare function barycentricWeights(points: Vector2[]): number[];
/**
 * Calculates the Lagrange basis polynomial
 * for a given set of x coordinates
 * based on previously computed barycentric weights.
 * @param points An array of coordinates. No two x should be the same.
 * @param weights An array of precomputed barycentric weights.
 * @param time The x coordinate to calculate the basis polynomial for.
 */
declare function barycentricLagrange(points: Vector2[], weights: number[], time: number): number;

declare const Interpolation_barycentricWeights: typeof barycentricWeights;
declare const Interpolation_barycentricLagrange: typeof barycentricLagrange;
declare namespace Interpolation {
  export {
    Interpolation_barycentricWeights as barycentricWeights,
    Interpolation_barycentricLagrange as barycentricLagrange,
  };
}

declare function clamp(value: number, min: number, max: number): number;
declare function clamp01(value: number): number;
declare function map(value: number, from1: number, to1: number, from2: number, to2: number): number;
declare function map01(value: number, from1: number, to1: number): number;
declare function lerp(value: number, a: number, b: number): number;
declare function lerpClamped01(value: number, a: number, b: number): number;
declare function lerpVector2(value: number, a: Vector2, b: Vector2): Vector2;
declare function lerpColor4(value: number, a: Color4, b: Color4): Color4;

declare const MathUtils_clamp: typeof clamp;
declare const MathUtils_clamp01: typeof clamp01;
declare const MathUtils_map: typeof map;
declare const MathUtils_map01: typeof map01;
declare const MathUtils_lerp: typeof lerp;
declare const MathUtils_lerpClamped01: typeof lerpClamped01;
declare const MathUtils_lerpVector2: typeof lerpVector2;
declare const MathUtils_lerpColor4: typeof lerpColor4;
declare namespace MathUtils {
  export {
    MathUtils_clamp as clamp,
    MathUtils_clamp01 as clamp01,
    MathUtils_map as map,
    MathUtils_map01 as map01,
    MathUtils_lerp as lerp,
    MathUtils_lerpClamped01 as lerpClamped01,
    MathUtils_lerpVector2 as lerpVector2,
    MathUtils_lerpColor4 as lerpColor4,
  };
}

declare class FastRandom {
  static MAX_INT32: number;
  static MAX_UINT32: number;
  static INT_MASK: number;
  static INT_TO_REAL: number;
  private _y;
  private _z;
  private _w;
  private _x;
  private _bitBuffer;
  private _bitIndex;
  /**
     * Creates a new instance of the Fast PRNG.
     * @param seed RNG seed.
     */
  constructor(seed: number);
  private _next;
  /**
     * Generates a random unsigned integer within the range [0, MAX_UINT32).
     * @returns The random value.
     */
  next(): number;
  /**
     * Generates a random unsigned integer value
     * within the range [lowerBound, upperBound).
     * @param lowerBound The lower bound of the range.
     * @param upperBound The upper bound of the range.
     * @returns The random integer value.
     */
  nextUInt(lowerBound?: number, upperBound?: number): number;
  /**
     * Generates a random integer value
     * within the range [lowerBound, upperBound).
     * @param lowerBound The lower bound of the range.
     * @param upperBound The upper bound of the range.
     * @returns The random integer value.
     */
  nextInt(lowerBound?: number, upperBound?: number): number;
  /**
     * Generates a random double value within the range [0, 1).
     * @returns The random value.
     */
  nextDouble(): number;
  /**
     * Generates a random boolean value.
     * Cached such that a random value is only generated once in every 32 calls.
     * @returns The random value.
     */
  nextBool(): boolean;
}

declare class RoundHelper {
  /**
     * Precision error to check if value is at midpoint.
     */
  static PRECISION_ERROR: number;
  /**
     * Rounds a value using "to even" or "away from zero" algroithm.
     * @param x The number to round.
     * @param mode Rounding mode.
     *  0 - "away from zero" algorithm.
     *  1 - "to even" algorithm.
     *
     * @returns Rounded number using one of two algorithms.
     */
  static round(x: number, mode?: number): number;
  /**
     * Rounds a value to the nearest number.
     * Midpoint values are rounded toward the nearest even number.
     * @param x The number to round.
     * @returns The rounded even number.
     */
  static roundToEven(x: number): number;
  /**
     * Rounds a value to the nearest number.
     * Midpoint values are rounded toward the nearest number that's away from zero.
     * @param x The number to round.
     * @returns The rounded even number.
     */
  static roundAwayFromZero(x: number): number;
  /**
     * Checks if a number is at midpoint.
     * @param x The number to check.
     * @returns If the number is at midpoint.
     */
  static isAtMidPoint(x: number): boolean;
}

declare class SortHelper {
  private static _QUICK_SORT_DEPTH_THRESHOLD;
  private static _INTRO_SORT_SIZE_THRESHOLD;
  /**
     * Sorts an array with mutation via depth limited quick sort algorithm.
     * @param keys The array to be sorted.
     * @param comparerFn The sorting function.
     * @returns The same array.
     */
  static depthSort(keys: any[], comparerFn?: ((a: any, b: any) => number)): any[];
  /**
     * Sorts an array with mutation via introspective sort algorithm.
     * @param keys The array to be sorted.
     * @param comparerFn The sorting function.
     * @returns The same array.
     */
  static introSort(keys: any[], comparerFn?: ((a: any, b: any) => number)): any[];
  private static _depthLimitedQuickSort;
  private static _introSort;
  private static _insertionSort;
  private static _pickPivotAndPartition;
  private static _heapsort;
  private static _downHeap;
  private static _swap;
  private static _swapIfGreater;
  private static _floorLog2;
  static defaultCompare: (x: unknown, y: unknown) => number;
  static toString: (obj: unknown) => string;
}

export { Accuracy, Anchor, Autoplay, Beatmap, BeatmapBreakEvent, BeatmapColorSection, BeatmapConverter, BeatmapDifficultySection, BeatmapEditorSection, BeatmapEventSection, BeatmapGeneralSection, BeatmapInfo, BeatmapMetadataSection, BeatmapProcessor, BinarySearch, BlendEquationMode, BlendingEquation, BlendingFactorDest, BlendingFactorSrc, BlendingMode, BlendingParameters, BlendingType, Cinema, CircularArcProperties, Color4, Command, CommandLoop, CommandTimeline, CommandTimelineGroup, CommandTrigger, CommandType, CompoundType, ControlPoint, ControlPointGroup, ControlPointInfo, ControlPointType, CountryCode, DifficultyAttributes, DifficultyCalculator, DifficultyHitObject, DifficultyPoint, DifficultyRange, DoubleTime, Easing, EasingType, Easy, EffectPoint, EffectType, EventGenerator, EventType, FastRandom, Flashlight, Grades, HalfTime, HardRock, Hidden, HighestRank, HitObject, HitResult, HitSample, HitSound, HitStatistics, HitType, HitWindows, IApplicableToBeatmap, IApplicableToConverter, IApplicableToDifficulty, IApplicableToHitObjects, IBeatmap, IBeatmapInfo, IConvertibleReplayFrame, IHasColumn, IHasCombo, IHasComboInformation, IHasCommands, IHasDistance, IHasDuration, IHasLegacyLastTickOffset, IHasNodeSamples, IHasPath, IHasPathWithRepeats, IHasPosition, IHasRepeats, IHasX, IHasY, IHitObject, IHoldableObject, IJsonableBeatmapInfo, IJsonableGrades, IJsonableHighestRank, IJsonableHitStatistics, IJsonableScoreInfo, IJsonableUserInfo, ILifeBarFrame, IMod, IReplay, IReplayFrame, IRuleset, IScore, IScoreInfo, ISlidableObject, ISliderEventDescriptor, ISpinnableObject, IStoryboardElement, IStoryboardElementWithDuration, IUserInfo, Interpolation, JsonableBeatmapInfo, JsonableScoreInfo, JsonableUserInfo, LayerType, LegacyReplayFrame, LegacyScoreExtensions, LevelInfo, LifeBarFrame, LimitedCapacityQueue, LoopType, MathUtils, ModBitwise, ModCombination, ModType, Nightcore, NoFail, NoMod, Origins, ParameterType, PathApproximator, PathPoint, PathType, Perfect, PerformanceAttributes, PerformanceCalculator, ProgressiveCalculationBeatmap, Rank, RankHistory, Relax, Replay, ReplayButtonState, ReplayConverter, ReplayFrame, ReverseQueue, RoundHelper, Ruleset, RulesetBeatmap, SampleBank, SamplePoint, SampleSet, Score, ScoreInfo, ScoreRank, Skill, SliderEventType, SliderPath, SortHelper, Storyboard, StoryboardAnimation, StoryboardLayer, StoryboardSample, StoryboardSprite, StoryboardVideo, StrainDecaySkill, StrainSkill, SuddenDeath, TimeSignature, TimedDifficultyAttributes, TimingPoint, UserInfo, Vector2 };
